{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to HealthChain","text":"<p>HealthChain \ud83d\udcab\ud83c\udfe5 is an open-source Python framework designed to streamline the development, testing, and validation of AI, Natural Language Processing, and Machine Learning applications in a healthcare context.</p> <p>  Join our Discord  Quickstart Guide</p>"},{"location":"#what-are-the-main-features","title":"What are the main features?","text":"<ul> <li> <p> Build a pipeline</p> <p>Create custom pipelines or use pre-built ones for your healthcare NLP and ML tasks</p> <p> Pipeline</p> </li> <li> <p> Test in a sandbox</p> <p>Test your models in a full health-context aware environment from day 1</p> <p> Sandbox</p> </li> <li> <p> Generate synthetic data</p> <p>Use the data generator to create synthetic healthcare data for testing and development</p> <p> Data Generator</p> </li> <li> <p> Contribute</p> <p>If you have an idea or suggestions, we'd love to hear from you!</p> <p> Community</p> </li> </ul>"},{"location":"#why-healthchain","title":"Why HealthChain?","text":"<p>You've probably heard every AI will revolutionize healthcare pitch by now, but if you're one of the people who think: wait, can we go beyond just vibe-checking and actually build products that are reliable, reactive, and easy to scale in complex healthcare systems? Then HealthChain is probably for you.</p> <p>Specifically, HealthChain addresses two challenges:</p> <ol> <li> <p>Scaling Electronic Health Record system (EHRs) integrations of real-time AI, NLP, and ML applications is a manual and time-consuming process.</p> </li> <li> <p>Testing and evaluating unstructured data in complex, outcome focused systems is a challenging and labour-intensive task.</p> </li> </ol> <p>We believe more efficient end-to-end pipeline and integration testing at an early stage in development will give you back time to focus on what actually matters: developing safer, more effective and more explainable models that scale to real-world adoption. Building products for healthcare in a process that is human-centric.</p> <p>HealthChain is made by a (very) small team with experience in software engineering, machine learning, and healthcare NLP. We understand that good data science is about more than just building models, and that good engineering is about more than just building systems. This rings especially true in healthcare, where people, processes, and technology all play a role in making an impact.</p> <p>For inquiries and collaborations, please get in touch!</p>"},{"location":"distribution/","title":"Licence and citations","text":"<p>HealthChain is licensed under Apache 2.0. To comply with the licence you need to add the following notice at the top every file that uses part of HealthChain code:</p> <pre><code>Copyright 2024 - dotimplement\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>You can install HealthChain with <code>pip</code>:</p> <pre><code>pip install healthchain\n</code></pre> <p>Note you need to download any libraries that you require separetly:</p> <pre><code>pip install langchain\npip install transformers\npip install torch\n...\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>After installing HealthChain, get up to speed quickly with the core components before diving further into the full documentation!</p>"},{"location":"quickstart/#core-components","title":"Core Components","text":""},{"location":"quickstart/#pipeline","title":"Pipeline \ud83d\udee0\ufe0f","text":"<p>HealthChain Pipelines provide a flexible way to build and manage processing pipelines for NLP and ML tasks that can easily integrate with electronic health record (EHR) systems.</p> <p>You can build pipelines with three different approaches:</p>"},{"location":"quickstart/#1-build-your-own-pipeline-with-inline-functions","title":"1. Build Your Own Pipeline with Inline Functions","text":"<p>This is the most flexible approach, ideal for quick experiments and prototyping. Initialize a pipeline type hinted with the container type you want to process, then add components to your pipeline with the <code>@add_node</code> decorator.</p> <p>Compile the pipeline with <code>.build()</code> to use it.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io import Document\n\nnlp_pipeline = Pipeline[Document]()\n\n@nlp_pipeline.add_node\ndef tokenize(doc: Document) -&gt; Document:\n    doc.tokens = doc.text.split()\n    return doc\n\n@nlp_pipeline.add_node\ndef pos_tag(doc: Document) -&gt; Document:\n    doc.pos_tags = [\"NOUN\" if token[0].isupper() else \"VERB\" for token in doc.tokens]\n    return doc\n\nnlp = nlp_pipeline.build()\n\ndoc = Document(\"Patient has a fracture of the left femur.\")\ndoc = nlp(doc)\n\nprint(doc.tokens)\nprint(doc.pos_tags)\n\n# ['Patient', 'has', 'fracture', 'of', 'left', 'femur.']\n# ['NOUN', 'VERB', 'VERB', 'VERB', 'VERB', 'VERB']\n</code></pre>"},{"location":"quickstart/#2-build-your-own-pipeline-with-components-models-and-connectors","title":"2. Build Your Own Pipeline with Components, Models, and Connectors","text":"<p>Components are stateful - they're classes instead of functions. They can be useful for grouping related processing steps together, setting configurations, or wrapping specific model loading steps.</p> <p>HealthChain comes with a few pre-built components, but you can also easily add your own. You can find more details on the Components and Models documentation pages.</p> <p>Add components to your pipeline with the <code>.add_node()</code> method and compile with <code>.build()</code>.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import TextPreProcessor, Model, TextPostProcessor\nfrom healthchain.io import Document\n\npipeline = Pipeline[Document]()\n\npipeline.add_node(TextPreProcessor())\npipeline.add_node(Model(model_path=\"path/to/model\"))\npipeline.add_node(TextPostProcessor())\n\npipe = pipeline.build()\n\ndoc = Document(\"Patient presents with hypertension.\")\noutput = pipe(doc)\n</code></pre> <p>Let's go one step further! You can use Connectors to work directly with CDA and FHIR data received from healthcare system APIs. Add Connectors to your pipeline with the <code>.add_input()</code> and <code>.add_output()</code> methods.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import Model\nfrom healthchain.io import CdaConnector\nfrom healthchain.models import CdaRequest\n\npipeline = Pipeline()\ncda_connector = CdaConnector()\n\npipeline.add_input(cda_connector)\npipeline.add_node(Model(model_path=\"path/to/model\"))\npipeline.add_output(cda_connector)\n\npipe = pipeline.build()\n\ncda_data = CdaRequest(document=\"&lt;CDA XML content&gt;\")\noutput = pipe(cda_data)\n</code></pre>"},{"location":"quickstart/#3-use-prebuilt-pipelines","title":"3. Use Prebuilt Pipelines","text":"<p>Prebuilt pipelines are pre-configured collections of Components, Models, and Connectors. They are built for specific use cases, offering the highest level of abstraction. This is the easiest way to get started if you already know the use case you want to build for.</p> <p>For a full list of available prebuilt pipelines and details on how to configure and customize them, see the Pipelines documentation page.</p> <pre><code>from healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest\n\npipeline = MedicalCodingPipeline.load(\"./path/to/model\")\n\ncda_data = CdaRequest(document=\"&lt;CDA XML content&gt;\")\noutput = pipeline(cda_data)\n</code></pre>"},{"location":"quickstart/#sandbox","title":"Sandbox \ud83e\uddea","text":"<p>Once you've built your pipeline, you might want to experiment with how it interacts with different healthcare systems. A sandbox helps you stage and test the end-to-end workflow of your pipeline application where real-time EHR integrations are involved.</p> <p>Running a sandbox will start a FastAPI server with pre-defined standardized endpoints and create a sandboxed environment for you to interact with your application.</p> <p>To create a sandbox, initialize a class that inherits from a type of UseCase and decorate it with the <code>@hc.sandbox</code> decorator.</p> <p>Every sandbox also requires a client function marked by <code>@hc.ehr</code> and a service function marked by <code>@hc.api</code>. A workflow must be specified when creating an EHR client.</p> <p>(Full Documentation on Sandbox and Use Cases)</p> <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDocumentation\nfrom healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest, CdaResponse, CcdData\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDocumentation):\n    def __init__(self) -&gt; None:\n        # Load your pipeline\n        self.pipeline = MedicalCodingPipeline.load(\"./path/to/model\")\n\n    @hc.ehr(workflow=\"sign-note-inpatient\")\n    def load_data_in_client(self) -&gt; CcdData:\n        # Load your data\n        with open('/path/to/data.xml', \"r\") as file:\n          xml_string = file.read()\n\n        return CcdData(cda_xml=xml_string)\n\n    @hc.api\n    def my_service(self, request: CdaRequest) -&gt; CdaResponse:\n        # Run your pipeline\n        results = self.pipeline(request)\n        return results\n\nif __name__ == \"__main__\":\n    clindoc = MyCoolSandbox()\n    clindoc.start_sandbox()\n</code></pre>"},{"location":"quickstart/#deploy-sandbox-locally-with-fastapi","title":"Deploy sandbox locally with FastAPI \ud83d\ude80","text":"<p>To run your sandbox:</p> <pre><code>healthchain run my_sandbox.py\n</code></pre> <p>This will start a server by default at <code>http://127.0.0.1:8000</code>, and you can interact with the exposed endpoints at <code>/docs</code>. Data generated from your sandbox runs is saved at <code>./output/</code> by default.</p>"},{"location":"quickstart/#utilities","title":"Utilities \u2699\ufe0f","text":""},{"location":"quickstart/#data-generator","title":"Data Generator","text":"<p>You can use the data generator to generate synthetic data for your sandbox runs.</p> <p>The <code>.generate()</code> is dependent on use case and workflow. For example, <code>CdsDataGenerator</code> will generate synthetic FHIR data suitable for the workflow specified by the use case.</p> <p>We're working on generating synthetic CDA data. If you're interested in contributing, please reach out!</p> <p>(Full Documentation on Data Generators)</p> Within clientOn its own <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.models import CdsFhirData\nfrom healthchain.data_generators import CdsDataGenerator\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDecisionSupport):\n    def __init__(self) -&gt; None:\n        self.data_generator = CdsDataGenerator()\n\n    @hc.ehr(workflow=\"patient-view\")\n    def load_data_in_client(self) -&gt; CdsFhirData:\n        data = self.data_generator.generate()\n        return data\n\n    @hc.api\n    def my_server(self, request) -&gt; None:\n        pass\n</code></pre> <pre><code>from healthchain.data_generators import CdsDataGenerator\nfrom healthchain.workflow import Workflow\n\n# Initialise data generator\ndata_generator = CdsDataGenerator()\n\n# Generate FHIR resources for use case workflow\ndata_generator.set_workflow(Workflow.encounter_discharge)\ndata = data_generator.generate()\n\nprint(data.model_dump())\n\n# {\n#    \"prefetch\": {\n#        \"entry\": [\n#            {\n#                \"resource\": ...\n#            }\n#        ]\n#    }\n#}\n</code></pre>"},{"location":"quickstart/#going-further","title":"Going further \u2728","text":"<p>Check out our Cookbook section for more worked examples! HealthChain is still in its early stages, so if you have any questions please feel free to reach us on Github or Discord.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/cda_parser/","title":"CDA Parser","text":""},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator","title":"<code>CdaAnnotator</code>","text":"<p>Annotates a Clinical Document Architecture (CDA) document.</p> PARAMETER DESCRIPTION <code>cda_data</code> <p>The CDA document data.</p> <p> TYPE: <code>ClinicalDocument</code> </p> <code>fallback</code> <p>The fallback value. Defaults to \"LLM\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LLM'</code> </p> ATTRIBUTE DESCRIPTION <code>clinical_document</code> <p>The CDA document data.</p> <p> TYPE: <code>ClinicalDocument</code> </p> <code>fallback</code> <p>The fallback value.</p> <p> TYPE: <code>str</code> </p> <code>problem_list</code> <p>The list of problems extracted from the CDA document.</p> <p> TYPE: <code>List[ProblemConcept]</code> </p> <code>medication_list</code> <p>The list of medications extracted from the CDA document.</p> <p> TYPE: <code>List[MedicationConcept]</code> </p> <code>allergy_list</code> <p>The list of allergies extracted from the CDA document.</p> <p> TYPE: <code>List[AllergyConcept]</code> </p> <code>note</code> <p>The note extracted from the CDA document.</p> <p> TYPE: <code>str</code> </p> METHOD DESCRIPTION <code>from_dict</code> <p>Dict): Creates a CdaAnnotator instance from a dictionary.</p> <code>from_xml</code> <p>str): Creates a CdaAnnotator instance from an XML string.</p> <code>add_to_problem_list</code> <p>List[ProblemConcept], overwrite: bool = False) -&gt; None: Adds a list of problem concepts to the problems section.</p> <code>export</code> <p>bool = True) -&gt; str: Exports the CDA document as an XML string.</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>class CdaAnnotator:\n    \"\"\"\n    Annotates a Clinical Document Architecture (CDA) document.\n\n    Args:\n        cda_data (ClinicalDocument): The CDA document data.\n        fallback (str, optional): The fallback value. Defaults to \"LLM\".\n\n    Attributes:\n        clinical_document (ClinicalDocument): The CDA document data.\n        fallback (str): The fallback value.\n        problem_list (List[ProblemConcept]): The list of problems extracted from the CDA document.\n        medication_list (List[MedicationConcept]): The list of medications extracted from the CDA document.\n        allergy_list (List[AllergyConcept]): The list of allergies extracted from the CDA document.\n        note (str): The note extracted from the CDA document.\n\n    Methods:\n        from_dict(cls, data: Dict): Creates a CdaAnnotator instance from a dictionary.\n        from_xml(cls, data: str): Creates a CdaAnnotator instance from an XML string.\n        add_to_problem_list(problems: List[ProblemConcept], overwrite: bool = False) -&gt; None: Adds a list of problem concepts to the problems section.\n        export(pretty_print: bool = True) -&gt; str: Exports the CDA document as an XML string.\n    \"\"\"\n\n    def __init__(self, cda_data: ClinicalDocument, fallback=\"LLM\") -&gt; None:\n        self.clinical_document = cda_data\n        self.fallback = fallback\n        self._get_ccd_sections()\n        self._extract_data()\n\n    @classmethod\n    def from_dict(cls, data: Dict) -&gt; \"CdaAnnotator\":\n        \"\"\"\n        Creates an instance of the class from a dictionary.\n\n        Args:\n            data (Dict): The dictionary containing the dictionary representation of the cda xml (using xmltodict.parse).\n\n        Returns:\n            CdaAnnotator: An instance of the class initialized with the data from the dictionary.\n        \"\"\"\n        clinical_document_model = ClinicalDocument(**data.get(\"ClinicalDocument\", {}))\n        return cls(cda_data=clinical_document_model)\n\n    @classmethod\n    def from_xml(cls, data: str) -&gt; \"CdaAnnotator\":\n        \"\"\"\n        Creates an instance of the CDAAnnotator class from an XML string.\n\n        Args:\n            data (str): The XML string representing the CDA document.\n\n        Returns:\n            CDAAnnotator: An instance of the CDAAnnotator class initialized with the parsed CDA data.\n        \"\"\"\n        cda_dict = xmltodict.parse(data)\n        clinical_document_model = ClinicalDocument(\n            **cda_dict.get(\"ClinicalDocument\", {})\n        )\n        return cls(cda_data=clinical_document_model)\n\n    def __str__(self):\n        problems = \"\"\n        allergies = \"\"\n        medications = \"\"\n\n        if self.problem_list:\n            problems = \"\\n\".join(\n                [problem.model_dump_json() for problem in self.problem_list]\n            )\n        if self.allergy_list:\n            allergies = \"\\n\".join(\n                [allergy.model_dump_json() for allergy in self.allergy_list]\n            )\n        if self.medication_list:\n            medications = \"\\n\".join(\n                [medication.model_dump_json() for medication in self.medication_list]\n            )\n\n        return problems + allergies + medications\n\n    def _get_ccd_sections(self) -&gt; None:\n        \"\"\"\n        Retrieves the different sections of the CCD document.\n\n        This method finds and assigns the problem section, medication section,\n        allergy section, and note section of the CCD document.\n\n        Returns:\n            None\n        \"\"\"\n        self._problem_section = self._find_problems_section()\n        self._medication_section = self._find_medications_section()\n        self._allergy_section = self._find_allergies_section()\n        self._note_section = self._find_notes_section()\n\n    def _extract_data(self) -&gt; None:\n        \"\"\"\n        Extracts data from the CDA document and assigns it to instance variables.\n\n        This method extracts problem list, medication list, allergy list, and note from the CDA document\n        and assigns them to the corresponding instance variables.\n\n        Returns:\n            None\n        \"\"\"\n        self.problem_list: List[ProblemConcept] = self._extract_problems()\n        self.medication_list: List[MedicationConcept] = self._extract_medications()\n        self.allergy_list: List[AllergyConcept] = self._extract_allergies()\n        self.note: str = self._extract_note()\n\n    def _find_section_by_code(self, section_code: str) -&gt; Optional[Section]:\n        \"\"\"\n        Finds a section in the clinical document by its code value.\n\n        Args:\n            section_code (str): The code of the section to find.\n\n        Returns:\n            Optional[Section]: The section with the specified code, or None if not found.\n        \"\"\"\n        components = self.clinical_document.component.structuredBody.component\n\n        if not isinstance(components, list):\n            components = [components]\n\n        for component in components:\n            code = component.section.code.code\n\n            if code is None:\n                continue\n            if code == section_code:\n                return component.section\n        log.warning(f\"unable to find section with code {section_code}\")\n        return None\n\n    def _find_section_by_template_id(self, section_id: str) -&gt; Optional[Section]:\n        \"\"\"\n        Finds a section in the clinical document by its template ID.\n\n        Args:\n            section_id (str): The template ID of the section to find.\n\n        Returns:\n            Optional[Section]: The section with the specified template ID, or None if not found.\n        \"\"\"\n        # NOTE not all CDAs have template ids in each section (don't ask me why)\n        # TODO: It's probably safer to parse by 'code' which is a required field\n        components = self.clinical_document.component.structuredBody.component\n        # Ensure components is a list\n        if not isinstance(components, list):\n            components = [components]\n\n        for component in components:\n            template_ids = component.section.templateId\n            if template_ids is None:\n                continue\n\n            if isinstance(template_ids, list):\n                for template_id in template_ids:\n                    if template_id.root == section_id:\n                        return component.section\n            elif template_ids.root == section_id:\n                return component.section\n\n        log.warning(f\"Unable to find section templateId {section_id}\")\n\n        return None\n\n    def _find_problems_section(self) -&gt; Optional[Section]:\n        return self._find_section_by_template_id(\n            SectionId.PROBLEM.value\n        ) or self._find_section_by_code(SectionCode.PROBLEM.value)\n\n    def _find_medications_section(self) -&gt; Optional[Section]:\n        return self._find_section_by_template_id(\n            SectionId.MEDICATION.value\n        ) or self._find_section_by_code(SectionCode.MEDICATION.value)\n\n    def _find_allergies_section(self) -&gt; Optional[Section]:\n        return self._find_section_by_template_id(\n            SectionId.ALLERGY.value\n        ) or self._find_section_by_code(SectionCode.ALLERGY.value)\n\n    def _find_notes_section(self) -&gt; Optional[Section]:\n        return self._find_section_by_template_id(\n            SectionId.NOTE.value\n        ) or self._find_section_by_code(SectionCode.NOTE.value)\n\n    def _extract_problems(self) -&gt; List[ProblemConcept]:\n        \"\"\"\n        Extracts problem concepts from the problem section of the CDA document.\n\n        Returns:\n            A list of ProblemConcept objects representing the extracted problem concepts.\n        \"\"\"\n        if not self._problem_section:\n            log.warning(\"Empty problem section!\")\n            return []\n\n        concepts = []\n\n        def get_problem_concept_from_cda_data_field(value: Dict) -&gt; ProblemConcept:\n            concept = ProblemConcept(_standard=\"cda\")\n            concept.code = value.get(\"@code\")\n            concept.code_system = value.get(\"@codeSystem\")\n            concept.code_system_name = value.get(\"@codeSystemName\")\n            concept.display_name = value.get(\"@displayName\")\n\n            return concept\n\n        entries = (\n            self._problem_section.entry\n            if isinstance(self._problem_section.entry, list)\n            else [self._problem_section.entry]\n        )\n\n        for entry in entries:\n            entry_relationship = entry.act.entryRelationship\n            values = get_value_from_entry_relationship(entry_relationship)\n            for value in values:\n                concept = get_problem_concept_from_cda_data_field(value)\n                concepts.append(concept)\n\n        return concepts\n\n    def _extract_medications(self) -&gt; List[MedicationConcept]:\n        \"\"\"\n        Extracts medication concepts from the medication section of the CDA document.\n\n        Returns:\n            A list of MedicationConcept objects representing the extracted medication concepts.\n        \"\"\"\n        if not self._medication_section:\n            log.warning(\"Empty medication section!\")\n            return []\n\n        def get_medication_concept_from_cda_data_field(\n            code: CD,\n            dose_quantity: Optional[IVL_PQ],\n            route_code: Optional[CE],\n            effective_times: Optional[Union[List[Dict], Dict]],\n            precondition: Optional[Dict],\n        ) -&gt; MedicationConcept:\n            concept = MedicationConcept(_standard=\"cda\")\n            concept.code = code.code\n            concept.code_system = code.codeSystem\n            concept.code_system_name = code.codeSystemName\n            concept.display_name = code.displayName\n\n            if dose_quantity:\n                concept.dosage = Quantity(\n                    _source=dose_quantity.model_dump(),\n                    value=dose_quantity.value,\n                    unit=dose_quantity.unit,\n                )\n            if route_code:\n                concept.route = Concept(\n                    code=route_code.code,\n                    code_system=route_code.codeSystem,\n                    code_system_name=route_code.codeSystemName,\n                    display_name=route_code.displayName,\n                )\n            if effective_times:\n                effective_times = (\n                    effective_times\n                    if isinstance(effective_times, list)\n                    else [effective_times]\n                )\n                # TODO: could refactor this into a pydantic validator\n                for effective_time in effective_times:\n                    if effective_time.get(\"@xsi:type\") == \"IVL_TS\":\n                        concept.duration = get_time_range_from_cda_value(effective_time)\n                        concept.duration._source = effective_time\n                    elif effective_time.get(\"@xsi:type\") == \"PIVL_TS\":\n                        period = effective_time.get(\"period\")\n                        if period:\n                            concept.frequency = TimeInterval(\n                                period=Quantity(\n                                    value=period.get(\"@value\"), unit=period.get(\"@unit\")\n                                ),\n                                institution_specified=effective_time.get(\n                                    \"@institutionSpecified\"\n                                ),\n                            )\n                        concept.frequency._source = effective_time\n\n            # TODO: this is read-only for now! can also extract status, translations, supply in entryRelationships\n            if precondition:\n                concept.precondition = precondition.model_dump(\n                    exclude_none=True, by_alias=True\n                )\n\n            return concept\n\n        def get_medication_details_from_substance_administration(\n            substance_administration: SubstanceAdministration,\n        ) -&gt; Tuple[\n            Optional[CD],\n            Optional[CE],\n            Optional[IVL_PQ],\n            Optional[Union[List[Dict], Dict]],\n            Optional[Dict],\n        ]:\n            # Get the medication code from the consumable\n            consumable = substance_administration.consumable\n            manufactured_product = (\n                consumable.manufacturedProduct if consumable else None\n            )\n            manufactured_material = (\n                manufactured_product.manufacturedMaterial\n                if manufactured_product\n                else None\n            )\n            code = manufactured_material.code if manufactured_material else None\n\n            return (\n                code,\n                substance_administration.doseQuantity,\n                substance_administration.routeCode,\n                substance_administration.effectiveTime,\n                substance_administration.precondition,\n            )\n\n        concepts = []\n\n        entries = (\n            self._medication_section.entry\n            if isinstance(self._medication_section.entry, list)\n            else [self._medication_section.entry]\n        )\n        for entry in entries:\n            substance_administration = entry.substanceAdministration\n            if not substance_administration:\n                log.warning(\"Substance administration not found in entry.\")\n                continue\n            code, dose_quantity, route_code, effective_times, precondition = (\n                get_medication_details_from_substance_administration(\n                    substance_administration\n                )\n            )\n            if not code:\n                log.warning(\"Code not found in the consumable\")\n                continue\n            concept = get_medication_concept_from_cda_data_field(\n                code, dose_quantity, route_code, effective_times, precondition\n            )\n            concepts.append(concept)\n\n        return concepts\n\n    def _extract_allergies(self) -&gt; List[AllergyConcept]:\n        if not self._allergy_section:\n            log.warning(\"Empty allergy section!\")\n            return []\n\n        concepts = []\n\n        def get_allergy_concept_from_cda_data_fields(\n            value: Dict,\n            allergen_name: str,\n            allergy_type: CD,\n            reaction: Dict,\n            severity: Dict,\n        ) -&gt; AllergyConcept:\n            concept = AllergyConcept(_standard=\"cda\")\n            concept.code = value.get(\"@code\")\n            concept.code_system = value.get(\"@codeSystem\")\n            concept.code_system_name = value.get(\"@codeSystemName\")\n            concept.display_name = value.get(\"@displayName\")\n            if concept.display_name is None:\n                concept.display_name = allergen_name\n\n            if allergy_type:\n                concept.allergy_type = Concept()\n                concept.allergy_type.code = allergy_type.code\n                concept.allergy_type.code_system = allergy_type.codeSystem\n                concept.allergy_type.code_system_name = allergy_type.codeSystemName\n                concept.allergy_type.display_name = allergy_type.displayName\n\n            if reaction:\n                concept.reaction = Concept()\n                concept.reaction.code = reaction.get(\"@code\")\n                concept.reaction.code_system = reaction.get(\"@codeSystem\")\n                concept.reaction.code_system_name = reaction.get(\"@codeSystemName\")\n                concept.reaction.display_name = reaction.get(\"@displayName\")\n\n            if severity:\n                concept.severity = Concept()\n                concept.severity.code = severity.get(\"@code\")\n                concept.severity.code_system = severity.get(\"@codeSystem\")\n                concept.severity.code_system_name = severity.get(\"@codeSystemName\")\n                concept.severity.display_name = severity.get(\"@displayName\")\n\n            return concept\n\n        def get_allergy_details_from_entry_relationship(\n            entry_relationship: EntryRelationship,\n        ) -&gt; Tuple[str, CD, Dict, Dict]:\n            allergen_name = None\n            allergy_type = None\n            reaction = None\n            severity = None\n\n            # TODO: Improve this\n\n            entry_relationships = (\n                entry_relationship\n                if isinstance(entry_relationship, list)\n                else [entry_relationship]\n            )\n            for entry_relationship in entry_relationships:\n                if check_for_entry_observation(entry_relationship):\n                    allergy_type = entry_relationship.observation.code\n                    observation = entry_relationship.observation\n                    allergen_name = (\n                        observation.participant.participantRole.playingEntity.name\n                    )\n\n                    if check_for_entry_observation(observation):\n                        observation_entry_relationships = (\n                            observation.entryRelationship\n                            if isinstance(observation.entryRelationship, list)\n                            else [observation.entryRelationship]\n                        )\n                        for observation_entry_rel in observation_entry_relationships:\n                            if check_has_template_id(\n                                observation_entry_rel.observation,\n                                \"1.3.6.1.4.1.19376.1.5.3.1.4.5\",\n                            ):\n                                reaction = observation_entry_rel.observation.value\n\n                        if check_for_entry_observation(\n                            observation_entry_rel.observation\n                        ):\n                            if check_has_template_id(\n                                observation_entry_rel.observation.entryRelationship.observation,\n                                \"1.3.6.1.4.1.19376.1.5.3.1.4.1\",\n                            ):\n                                severity = observation_entry_rel.observation.entryRelationship.observation.value\n\n            return allergen_name, allergy_type, reaction, severity\n\n        entries = (\n            self._allergy_section.entry\n            if isinstance(self._allergy_section.entry, list)\n            else [self._allergy_section.entry]\n        )\n        for entry in entries:\n            entry_relationship = entry.act.entryRelationship\n            values = get_value_from_entry_relationship(entry_relationship)\n\n            allergen_name, allergy_type, reaction, severity = (\n                get_allergy_details_from_entry_relationship(entry_relationship)\n            )\n\n            for value in values:\n                concept = get_allergy_concept_from_cda_data_fields(\n                    value, allergen_name, allergy_type, reaction, severity\n                )\n                concepts.append(concept)\n\n        return concepts\n\n    def _extract_note(self) -&gt; str:\n        \"\"\"\n        Extracts the note section from the CDA document.\n\n        Returns:\n            str: The extracted note section as a string.\n        \"\"\"\n        # TODO: need to handle / escape html tags within the note section, parse with right field\n        if not self._note_section:\n            log.warning(\"Empty notes section!\")\n            return []\n\n        return self._note_section.text\n\n    def _add_new_problem_entry(\n        self,\n        new_problem: ProblemConcept,\n        timestamp: str,\n        act_id: str,\n        problem_reference_name: str,\n    ) -&gt; None:\n        \"\"\"\n        Adds a new problem entry to the problem section of the CDA document.\n\n        Args:\n            new_problem (ProblemConcept): The new problem concept to be added.\n            timestamp (str): The timestamp of the entry.\n            act_id (str): The ID of the act.\n            problem_reference_name (str): The reference name of the problem.\n\n        Returns:\n            None\n        \"\"\"\n        # TODO: This will need work\n        template = {\n            \"act\": {\n                \"@classCode\": \"ACT\",\n                \"@moodCode\": \"EVN\",\n                \"templateId\": [\n                    {\"@root\": \"2.16.840.1.113883.10.20.1.27\"},\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5.1\"},\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5.2\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.32.7\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.83.7\"},\n                ],\n                \"id\": {\"@root\": act_id},\n                \"code\": {\"@nullflavor\": \"NA\"},\n                \"statusCode\": {\"@code\": \"active\"},\n                \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                \"entryRelationship\": {\n                    \"@typeCode\": \"SUBJ\",\n                    \"@inversionInd\": False,\n                    \"observation\": {\n                        \"@classCode\": \"OBS\",\n                        \"@moodCode\": \"EVN\",\n                        \"templateId\": [\n                            {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5\"},\n                            {\"@root\": \"2.16.840.1.113883.10.20.1.28\"},\n                        ],\n                        \"id\": {\"@root\": act_id},\n                        \"code\": {\n                            \"@code\": \"55607006\",\n                            \"@codeSystem\": \"2.16.840.1.113883.6.96\",\n                            \"@codeSystemName\": \"SNOMED CT\",\n                            \"@displayName\": \"Problem\",\n                        },\n                        \"text\": {\"reference\": {\"@value\": problem_reference_name}},\n                        \"value\": {\n                            \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                            \"@code\": new_problem.code,\n                            \"@codeSystem\": new_problem.code_system,\n                            \"@codeSystemName\": new_problem.code_system_name,\n                            \"@displayName\": new_problem.display_name,\n                            \"originalText\": {\n                                \"reference\": {\"@value\": problem_reference_name}\n                            },\n                            \"@xsi:type\": \"CD\",\n                        },\n                        \"statusCode\": {\"@code\": \"completed\"},\n                        \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                        \"entryRelationship\": {\n                            \"@typeCode\": \"REFR\",\n                            \"observation\": {\n                                \"@classCode\": \"OBS\",\n                                \"@moodCode\": \"EVN\",\n                                \"code\": {\n                                    \"@code\": \"33999-4\",\n                                    \"@codeSystem\": \"2.16.840.1.113883.6.1\",\n                                    \"@displayName\": \"Status\",\n                                },\n                                \"value\": {\n                                    \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                                    \"@code\": \"55561003\",\n                                    \"@codeSystem\": \"2.16.840.1.113883.6.96\",\n                                    \"@displayName\": \"Active\",\n                                    \"@xsi:type\": \"CE\",\n                                },\n                                \"statusCode\": {\"@code\": \"completed\"},\n                                \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                            },\n                        },\n                    },\n                },\n            }\n        }\n        if not isinstance(self._problem_section.entry, list):\n            self._problem_section.entry = [self._problem_section.entry]\n\n        new_entry = Entry(**template)\n        self._problem_section.entry.append(new_entry)\n\n    def add_to_problem_list(\n        self, problems: List[ProblemConcept], overwrite: bool = False\n    ) -&gt; None:\n        \"\"\"\n        Adds a list of problem lists to the problems section.\n\n        Args:\n            problems (List[ProblemConcept]): A list of problem concepts to be added.\n            overwrite (bool, optional): If True, the existing problem list will be overwritten.\n                Defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        if self._problem_section is None:\n            log.warning(\n                \"Skipping: No problem section to add to, check your CDA configuration\"\n            )\n            return\n\n        timestamp = datetime.now().strftime(format=\"%Y%m%d\")\n        act_id = str(uuid.uuid4())\n        problem_reference_name = \"#p\" + str(uuid.uuid4())[:8] + \"name\"\n\n        if overwrite:\n            self._problem_section.entry = []\n\n        added_problems = []\n\n        for problem in problems:\n            if problem in self.problem_list:\n                log.debug(\n                    f\"Skipping: Problem {problem.display_name} already exists in the problem list.\"\n                )\n                continue\n            log.debug(f\"Adding problem: {problem}\")\n            self._add_new_problem_entry(\n                new_problem=problem,\n                timestamp=timestamp,\n                act_id=act_id,\n                problem_reference_name=problem_reference_name,\n            )\n            added_problems.append(problem)\n\n        if overwrite:\n            self.problem_list = added_problems\n        else:\n            self.problem_list.extend(added_problems)\n\n    def _add_new_medication_entry(\n        self,\n        new_medication: MedicationConcept,\n        timestamp: str,\n        subad_id: str,\n        medication_reference_name: str,\n    ):\n        effective_times = []\n        if new_medication.frequency:\n            effective_times.append(\n                {\n                    \"@xsi:type\": \"PIVL_TS\",\n                    \"@institutionSpecified\": new_medication.frequency.institution_specified,\n                    \"@operator\": \"A\",\n                    \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                    \"period\": {\n                        \"@unit\": new_medication.frequency.period.unit,\n                        \"@value\": new_medication.frequency.period.value,\n                    },\n                }\n            )\n        if new_medication.duration:\n            low = {\"@nullFlavor\": \"UNK\"}\n            high = {\"@nullFlavor\": \"UNK\"}\n            if new_medication.duration.low:\n                low = {\"@value\": new_medication.duration.low.value}\n            if new_medication.duration.high:\n                high = {\"@value\": new_medication.duration.high.value}\n            effective_times.append(\n                {\n                    \"@xsi:type\": \"IVL_TS\",\n                    \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                    \"low\": low,\n                    \"high\": high,\n                }\n            )\n\n        if len(effective_times) == 1:\n            effective_times = effective_times[0]\n\n        template = {\n            \"substanceAdministration\": {\n                \"@classCode\": \"SBADM\",\n                \"@moodCode\": \"INT\",\n                \"templateId\": [\n                    {\"@root\": \"2.16.840.1.113883.10.20.1.24\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.83.8\"},\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.7\"},\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.7.1\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.32.8\"},\n                ],\n                \"id\": {\"@root\": subad_id},\n                \"statusCode\": {\"@code\": \"completed\"},\n            }\n        }\n        # Add dosage, route, duration, frequency\n        if effective_times:\n            template[\"substanceAdministration\"][\"effectiveTime\"] = effective_times\n        if new_medication.route:\n            template[\"substanceAdministration\"][\"routeCode\"] = {\n                \"@code\": new_medication.route.code,\n                \"@codeSystem\": new_medication.route.code_system,\n                \"@codeSystemDisplayName\": new_medication.route.code_system_name,\n                \"@displayName\": new_medication.route.display_name,\n            }\n        if new_medication.dosage:\n            template[\"substanceAdministration\"][\"doseQuantity\"] = {\n                \"@value\": new_medication.dosage.value,\n                \"@unit\": new_medication.dosage.unit,\n            }\n\n        # Add medication entry\n        template[\"substanceAdministration\"][\"consumable\"] = {\n            \"@typeCode\": \"CSM\",\n            \"manufacturedProduct\": {\n                \"@classCode\": \"MANU\",\n                \"templateId\": [\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.7.2\"},\n                    {\"@root\": \"2.16.840.1.113883.10.20.1.53\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.32.9\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.83.8.2\"},\n                ],\n                \"manufacturedMaterial\": {\n                    \"code\": {\n                        \"@code\": new_medication.code,\n                        \"@codeSystem\": new_medication.code_system,\n                        \"@codeSystemName\": new_medication.code_system_name,\n                        \"@displayName\": new_medication.display_name,\n                        \"originalText\": {\n                            \"reference\": {\"@value\": medication_reference_name}\n                        },\n                    }\n                },\n            },\n        }\n\n        # Add an Active status\n        template[\"substanceAdministration\"][\"entryRelationship\"] = (\n            {\n                \"@typeCode\": \"REFR\",\n                \"observation\": {\n                    \"@classCode\": \"OBS\",\n                    \"@moodCode\": \"EVN\",\n                    \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                    \"templateId\": {\"@root\": \"2.16.840.1.113883.10.20.1.47\"},\n                    \"code\": {\n                        \"@code\": \"33999-4\",\n                        \"@codeSystem\": \"2.16.840.1.113883.6.1\",\n                        \"@codeSystemName\": \"LOINC\",\n                        \"@displayName\": \"Status\",\n                    },\n                    \"value\": {\n                        \"@code\": \"755561003\",\n                        \"@codeSystem\": \"2.16.840.1.113883.6.96\",\n                        \"@codeSystemName\": \"SNOMED CT\",\n                        \"@xsi:type\": \"CE\",\n                        \"@displayName\": \"Active\",\n                        \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                    },\n                    \"statusCode\": {\"@code\": \"completed\"},\n                },\n            },\n        )\n        template[\"substanceAdministration\"][\"precondition\"] = (\n            new_medication.precondition\n        )\n\n        if not isinstance(self._medication_section.entry, list):\n            self._medication_section.entry = [self._medication_section.entry]\n\n        new_entry = Entry(**template)\n        self._medication_section.entry.append(new_entry)\n\n    def add_to_medication_list(\n        self, medications: List[MedicationConcept], overwrite: bool = False\n    ) -&gt; None:\n        \"\"\"\n        Adds medications to the medication list.\n\n        Args:\n            medications (List[MedicationConcept]): A list of MedicationConcept objects representing the medications to be added.\n            overwrite (bool, optional): If True, the existing medication list will be overwritten. Defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        if self._medication_section is None:\n            log.warning(\n                \"Skipping: No medication section to add to, check your CDA configuration\"\n            )\n            return\n\n        timestamp = datetime.now().strftime(format=\"%Y%m%d\")\n        subad_id = str(uuid.uuid4())\n        medication_reference_name = \"#m\" + str(uuid.uuid4())[:8] + \"name\"\n\n        if overwrite:\n            self._medication_section.entry = []\n\n        added_medications = []\n\n        for medication in medications:\n            if medication in self.medication_list:\n                log.debug(\n                    f\"Skipping: medication {medication.display_name} already exists in the medication list.\"\n                )\n                continue\n            log.debug(f\"Adding medication {medication}\")\n            self._add_new_medication_entry(\n                new_medication=medication,\n                timestamp=timestamp,\n                subad_id=subad_id,\n                medication_reference_name=medication_reference_name,\n            )\n            added_medications.append(medication)\n\n        if overwrite:\n            self.medication_list = added_medications\n        else:\n            self.medication_list.extend(added_medications)\n\n    def _add_new_allergy_entry(\n        self,\n        new_allergy: AllergyConcept,\n        timestamp: str,\n        act_id: str,\n        allergy_reference_name: str,\n    ) -&gt; None:\n        \"\"\"\n        Adds a new allergy entry to the allergy section of the CDA document.\n\n        Args:\n            new_allergy (AllergyConcept): The new allergy concept to be added.\n            timestamp (str): The timestamp of the entry.\n            act_id (str): The ID of the act.\n            allergy_reference_name (str): The reference name of the allergy.\n\n        Returns:\n            None\n        \"\"\"\n\n        template = {\n            \"act\": {\n                \"@classCode\": \"ACT\",\n                \"@moodCode\": \"EVN\",\n                \"templateId\": [\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5.1\"},\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5.3\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.32.6\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.83.6\"},\n                ],\n                \"id\": {\"@root\": act_id},\n                \"code\": {\"@nullFlavor\": \"NA\"},\n                \"statusCode\": {\"@code\": \"active\"},\n                \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                \"entryRelationship\": {\n                    \"@typeCode\": \"SUBJ\",\n                    \"@inversionInd\": False,\n                    \"observation\": {\n                        \"@classCode\": \"OBS\",\n                        \"@moodCode\": \"EVN\",\n                        \"templateId\": [\n                            {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5\"},\n                            {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.6\"},\n                            {\"@root\": \"2.16.840.1.113883.10.20.1.18\"},\n                            {\n                                \"@root\": \"1.3.6.1.4.1.19376.1.5.3.1\",\n                                \"@extension\": \"allergy\",\n                            },\n                            {\"@root\": \"2.16.840.1.113883.10.20.1.28\"},\n                        ],\n                        \"id\": {\"@root\": act_id},\n                        \"text\": {\"reference\": {\"@value\": allergy_reference_name}},\n                        \"statusCode\": {\"@code\": \"completed\"},\n                        \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                    },\n                },\n            }\n        }\n        allergen_observation = template[\"act\"][\"entryRelationship\"][\"observation\"]\n\n        # Attach allergy type code\n        if new_allergy.allergy_type:\n            allergen_observation[\"code\"] = {\n                \"@code\": new_allergy.allergy_type.code,\n                \"@codeSystem\": new_allergy.allergy_type.code_system,\n                \"@codeSystemName\": new_allergy.allergy_type.code_system_name,\n                \"@displayName\": new_allergy.allergy_type.display_name,\n            }\n        else:\n            raise ValueError(\"Allergy_type code cannot be missing when adding allergy.\")\n\n        # Attach allergen code to value and participant\n        allergen_observation[\"value\"] = {\n            \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n            \"@code\": new_allergy.code,\n            \"@codeSystem\": new_allergy.code_system,\n            \"@codeSystemName\": new_allergy.code_system_name,\n            \"@displayName\": new_allergy.display_name,\n            \"originalText\": {\"reference\": {\"@value\": allergy_reference_name}},\n            \"@xsi:type\": \"CD\",\n        }\n\n        allergen_observation[\"participant\"] = {\n            \"@typeCode\": \"CSM\",\n            \"participantRole\": {\n                \"@classCode\": \"MANU\",\n                \"playingEntity\": {\n                    \"@classCode\": \"MMAT\",\n                    \"code\": {\n                        \"originalText\": {\n                            \"reference\": {\"@value\": allergy_reference_name}\n                        },\n                        \"@code\": new_allergy.code,\n                        \"@codeSystem\": new_allergy.code_system,\n                        \"@codeSystemName\": new_allergy.code_system_name,\n                        \"@displayName\": new_allergy.display_name,\n                    },\n                    \"name\": new_allergy.display_name,\n                },\n            },\n        }\n\n        # We need an entryRelationship if either reaction or severity is present\n        if new_allergy.reaction or new_allergy.severity:\n            allergen_observation[\"entryRelationship\"] = {\n                \"@typeCode\": \"MFST\",\n                \"observation\": {\n                    \"@classCode\": \"OBS\",\n                    \"@moodCode\": \"EVN\",\n                    \"templateId\": [\n                        {\"@root\": \"2.16.840.1.113883.10.20.1.54\"},\n                        {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5\"},\n                        {\n                            \"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5\",\n                            \"@extension\": \"reaction\",\n                        },\n                    ],\n                    \"id\": {\"@root\": act_id},\n                    \"code\": {\"@code\": \"RXNASSESS\"},\n                    \"text\": {\n                        \"reference\": {\"@value\": allergy_reference_name + \"reaction\"}\n                    },\n                    \"statusCode\": {\"@code\": \"completed\"},\n                    \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                },\n            }\n            # Attach reaction code if given otherwise attach nullFlavor\n            if new_allergy.reaction:\n                allergen_observation[\"entryRelationship\"][\"observation\"][\"value\"] = {\n                    \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                    \"@code\": new_allergy.reaction.code,\n                    \"@codeSystem\": new_allergy.reaction.code_system,\n                    \"@codeSystemName\": new_allergy.reaction.code_system_name,\n                    \"@displayName\": new_allergy.reaction.display_name,\n                    \"@xsi:type\": \"CD\",\n                    \"originalText\": {\n                        \"reference\": {\"@value\": allergy_reference_name + \"reaction\"}\n                    },\n                }\n            else:\n                allergen_observation[\"entryRelationship\"][\"observation\"][\"value\"] = {\n                    \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                    \"@nullFlavor\": \"OTH\",\n                    \"@xsi:type\": \"CD\",\n                }\n            # Attach severity code if given\n            if new_allergy.severity:\n                allergen_observation[\"entryRelationship\"][\"observation\"][\n                    \"entryRelationship\"\n                ] = {\n                    \"@typeCode\": \"SUBJ\",\n                    \"observation\": {\n                        \"@classCode\": \"OBS\",\n                        \"@moodCode\": \"EVN\",\n                        \"templateId\": [\n                            {\"@root\": \"2.16.840.1.113883.10.20.1.55\"},\n                            {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.1\"},\n                        ],\n                        \"code\": {\n                            \"@code\": \"SEV\",\n                            \"@codeSystem\": \"2.16.840.1.113883.5.4\",\n                            \"@codeSystemName\": \"ActCode\",\n                            \"@displayName\": \"Severity\",\n                        },\n                        \"text\": {\n                            \"reference\": {\"@value\": allergy_reference_name + \"severity\"}\n                        },\n                        \"statusCode\": {\"@code\": \"completed\"},\n                        \"value\": {\n                            \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                            \"@code\": new_allergy.severity.code,\n                            \"@codeSystem\": new_allergy.severity.code_system,\n                            \"@codeSystemName\": new_allergy.severity.code_system_name,\n                            \"@displayName\": new_allergy.severity.display_name,\n                            \"@xsi:type\": \"CD\",\n                        },\n                    },\n                }\n\n        if not isinstance(self._allergy_section.entry, list):\n            self._allergy_section.entry = [self._allergy_section.entry]\n\n        new_entry = Entry(**template)\n        self._allergy_section.entry.append(new_entry)\n\n    def add_to_allergy_list(\n        self, allergies: List[AllergyConcept], overwrite: bool = False\n    ) -&gt; None:\n        if self._allergy_section is None:\n            log.warning(\n                \"Skipping: No allergy section to add to, check your CDA configuration\"\n            )\n            return\n\n        timestamp = datetime.now().strftime(format=\"%Y%m%d\")\n        act_id = str(uuid.uuid4())\n        allergy_reference_name = \"#a\" + str(uuid.uuid4())[:8] + \"name\"\n\n        if overwrite:\n            self._allergy_section.entry = []\n\n        added_allergies = []\n\n        for allergy in allergies:\n            if allergy in self.allergy_list:\n                log.debug(\n                    f\"Skipping: Allergy {allergy.display_name} already exists in the allergy list.\"\n                )\n                continue\n            log.debug(f\"Adding allergy: {allergy}\")\n            self._add_new_allergy_entry(\n                new_allergy=allergy,\n                timestamp=timestamp,\n                act_id=act_id,\n                allergy_reference_name=allergy_reference_name,\n            )\n            added_allergies.append(allergy)\n\n        if overwrite:\n            self.allergy_list = added_allergies\n        else:\n            self.allergy_list.extend(added_allergies)\n\n    def export(self, pretty_print: bool = True) -&gt; str:\n        \"\"\"\n        Exports CDA document as an XML string\n        \"\"\"\n        out_string = xmltodict.unparse(\n            {\n                \"ClinicalDocument\": self.clinical_document.model_dump(\n                    exclude_none=True, exclude_unset=True, by_alias=True\n                )\n            },\n            pretty=pretty_print,\n        )\n        # Fixes self closing tags - this is not strictly necessary, just looks more readable\n        pattern = r\"(&lt;(\\w+)(\\s+[^&gt;]*?)?)&gt;&lt;/\\2&gt;\"\n        export_xml = re.sub(pattern, r\"\\1/&gt;\", out_string)\n\n        return export_xml\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator.add_to_medication_list","title":"<code>add_to_medication_list(medications, overwrite=False)</code>","text":"<p>Adds medications to the medication list.</p> PARAMETER DESCRIPTION <code>medications</code> <p>A list of MedicationConcept objects representing the medications to be added.</p> <p> TYPE: <code>List[MedicationConcept]</code> </p> <code>overwrite</code> <p>If True, the existing medication list will be overwritten. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def add_to_medication_list(\n    self, medications: List[MedicationConcept], overwrite: bool = False\n) -&gt; None:\n    \"\"\"\n    Adds medications to the medication list.\n\n    Args:\n        medications (List[MedicationConcept]): A list of MedicationConcept objects representing the medications to be added.\n        overwrite (bool, optional): If True, the existing medication list will be overwritten. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    if self._medication_section is None:\n        log.warning(\n            \"Skipping: No medication section to add to, check your CDA configuration\"\n        )\n        return\n\n    timestamp = datetime.now().strftime(format=\"%Y%m%d\")\n    subad_id = str(uuid.uuid4())\n    medication_reference_name = \"#m\" + str(uuid.uuid4())[:8] + \"name\"\n\n    if overwrite:\n        self._medication_section.entry = []\n\n    added_medications = []\n\n    for medication in medications:\n        if medication in self.medication_list:\n            log.debug(\n                f\"Skipping: medication {medication.display_name} already exists in the medication list.\"\n            )\n            continue\n        log.debug(f\"Adding medication {medication}\")\n        self._add_new_medication_entry(\n            new_medication=medication,\n            timestamp=timestamp,\n            subad_id=subad_id,\n            medication_reference_name=medication_reference_name,\n        )\n        added_medications.append(medication)\n\n    if overwrite:\n        self.medication_list = added_medications\n    else:\n        self.medication_list.extend(added_medications)\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator.add_to_problem_list","title":"<code>add_to_problem_list(problems, overwrite=False)</code>","text":"<p>Adds a list of problem lists to the problems section.</p> PARAMETER DESCRIPTION <code>problems</code> <p>A list of problem concepts to be added.</p> <p> TYPE: <code>List[ProblemConcept]</code> </p> <code>overwrite</code> <p>If True, the existing problem list will be overwritten. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def add_to_problem_list(\n    self, problems: List[ProblemConcept], overwrite: bool = False\n) -&gt; None:\n    \"\"\"\n    Adds a list of problem lists to the problems section.\n\n    Args:\n        problems (List[ProblemConcept]): A list of problem concepts to be added.\n        overwrite (bool, optional): If True, the existing problem list will be overwritten.\n            Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    if self._problem_section is None:\n        log.warning(\n            \"Skipping: No problem section to add to, check your CDA configuration\"\n        )\n        return\n\n    timestamp = datetime.now().strftime(format=\"%Y%m%d\")\n    act_id = str(uuid.uuid4())\n    problem_reference_name = \"#p\" + str(uuid.uuid4())[:8] + \"name\"\n\n    if overwrite:\n        self._problem_section.entry = []\n\n    added_problems = []\n\n    for problem in problems:\n        if problem in self.problem_list:\n            log.debug(\n                f\"Skipping: Problem {problem.display_name} already exists in the problem list.\"\n            )\n            continue\n        log.debug(f\"Adding problem: {problem}\")\n        self._add_new_problem_entry(\n            new_problem=problem,\n            timestamp=timestamp,\n            act_id=act_id,\n            problem_reference_name=problem_reference_name,\n        )\n        added_problems.append(problem)\n\n    if overwrite:\n        self.problem_list = added_problems\n    else:\n        self.problem_list.extend(added_problems)\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator.export","title":"<code>export(pretty_print=True)</code>","text":"<p>Exports CDA document as an XML string</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def export(self, pretty_print: bool = True) -&gt; str:\n    \"\"\"\n    Exports CDA document as an XML string\n    \"\"\"\n    out_string = xmltodict.unparse(\n        {\n            \"ClinicalDocument\": self.clinical_document.model_dump(\n                exclude_none=True, exclude_unset=True, by_alias=True\n            )\n        },\n        pretty=pretty_print,\n    )\n    # Fixes self closing tags - this is not strictly necessary, just looks more readable\n    pattern = r\"(&lt;(\\w+)(\\s+[^&gt;]*?)?)&gt;&lt;/\\2&gt;\"\n    export_xml = re.sub(pattern, r\"\\1/&gt;\", out_string)\n\n    return export_xml\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Creates an instance of the class from a dictionary.</p> PARAMETER DESCRIPTION <code>data</code> <p>The dictionary containing the dictionary representation of the cda xml (using xmltodict.parse).</p> <p> TYPE: <code>Dict</code> </p> RETURNS DESCRIPTION <code>CdaAnnotator</code> <p>An instance of the class initialized with the data from the dictionary.</p> <p> TYPE: <code>CdaAnnotator</code> </p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict) -&gt; \"CdaAnnotator\":\n    \"\"\"\n    Creates an instance of the class from a dictionary.\n\n    Args:\n        data (Dict): The dictionary containing the dictionary representation of the cda xml (using xmltodict.parse).\n\n    Returns:\n        CdaAnnotator: An instance of the class initialized with the data from the dictionary.\n    \"\"\"\n    clinical_document_model = ClinicalDocument(**data.get(\"ClinicalDocument\", {}))\n    return cls(cda_data=clinical_document_model)\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator.from_xml","title":"<code>from_xml(data)</code>  <code>classmethod</code>","text":"<p>Creates an instance of the CDAAnnotator class from an XML string.</p> PARAMETER DESCRIPTION <code>data</code> <p>The XML string representing the CDA document.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>CDAAnnotator</code> <p>An instance of the CDAAnnotator class initialized with the parsed CDA data.</p> <p> TYPE: <code>CdaAnnotator</code> </p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>@classmethod\ndef from_xml(cls, data: str) -&gt; \"CdaAnnotator\":\n    \"\"\"\n    Creates an instance of the CDAAnnotator class from an XML string.\n\n    Args:\n        data (str): The XML string representing the CDA document.\n\n    Returns:\n        CDAAnnotator: An instance of the CDAAnnotator class initialized with the parsed CDA data.\n    \"\"\"\n    cda_dict = xmltodict.parse(data)\n    clinical_document_model = ClinicalDocument(\n        **cda_dict.get(\"ClinicalDocument\", {})\n    )\n    return cls(cda_data=clinical_document_model)\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.check_for_entry_observation","title":"<code>check_for_entry_observation(entry)</code>","text":"<p>Checks if the given entry contains an observation.</p> PARAMETER DESCRIPTION <code>entry</code> <p>The entry to check.</p> <p> TYPE: <code>Entry</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the entry contains an observation, False otherwise.</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def check_for_entry_observation(entry: Entry) -&gt; bool:\n    \"\"\"\n    Checks if the given entry contains an observation.\n\n    Args:\n        entry: The entry to check.\n\n    Returns:\n        True if the entry contains an observation, False otherwise.\n    \"\"\"\n    if isinstance(entry, EntryRelationship):\n        if entry.observation:\n            return True\n    elif isinstance(entry, Observation):\n        if entry.entryRelationship:\n            return check_for_entry_observation(entry.entryRelationship)\n    elif isinstance(entry, list):\n        for item in entry:\n            if isinstance(item, EntryRelationship):\n                if item.observation:\n                    return True\n            elif isinstance(item, Observation):\n                if item.entryRelationship:\n                    return check_for_entry_observation(item.entryRelationship)\n    return False\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.check_has_template_id","title":"<code>check_has_template_id(section, template_id)</code>","text":"<p>Check if the given section has a matching template ID.</p> PARAMETER DESCRIPTION <code>section</code> <p>The section to check.</p> <p> TYPE: <code>Section</code> </p> <code>template_id</code> <p>The template ID to match.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the section has a matching template ID, False otherwise.</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def check_has_template_id(section: Section, template_id: str) -&gt; bool:\n    \"\"\"\n    Check if the given section has a matching template ID.\n\n    Args:\n        section: The section to check.\n        template_id: The template ID to match.\n\n    Returns:\n        True if the section has a matching template ID, False otherwise.\n    \"\"\"\n\n    if section.templateId is None:\n        return False\n\n    if isinstance(section.templateId, list):\n        for template in section.templateId:\n            if template.root == template_id:\n                return True\n    elif section.templateId.root == template_id:\n        return True\n\n    return False\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.get_time_range_from_cda_value","title":"<code>get_time_range_from_cda_value(value)</code>","text":"<p>Converts a dictionary representing a time range from a CDA value into a Range object.</p> PARAMETER DESCRIPTION <code>value</code> <p>A dictionary representing the CDA value.</p> <p> TYPE: <code>Dict</code> </p> RETURNS DESCRIPTION <code>Range</code> <p>A Range object representing the time range.</p> <p> TYPE: <code>Range</code> </p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def get_time_range_from_cda_value(value: Dict) -&gt; Range:\n    \"\"\"\n    Converts a dictionary representing a time range from a CDA value into a Range object.\n\n    Args:\n        value (Dict): A dictionary representing the CDA value.\n\n    Returns:\n        Range: A Range object representing the time range.\n\n    \"\"\"\n    range_model = Range(\n        low=Quantity(\n            value=value.get(\"low\", {}).get(\"@value\"),\n            unit=value.get(\"low\", {}).get(\"@unit\"),\n        ),\n        high=Quantity(\n            value=value.get(\"high\", {}).get(\"@value\"),\n            unit=value.get(\"high\", {}).get(\"@unit\"),\n        ),\n    )\n    if range_model.low.value is None:\n        range_model.low = None\n    if range_model.high.value is None:\n        range_model.high = None\n\n    return range_model\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.get_value_from_entry_relationship","title":"<code>get_value_from_entry_relationship(entry_relationship)</code>","text":"<p>Retrieves the values from the given entry_relationship.</p> PARAMETER DESCRIPTION <code>entry_relationship</code> <p>The entry_relationship object to extract values from.</p> <p> TYPE: <code>EntryRelationship</code> </p> RETURNS DESCRIPTION <code>List</code> <p>A list of values extracted from the entry_relationship.</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def get_value_from_entry_relationship(entry_relationship: EntryRelationship) -&gt; List:\n    \"\"\"\n    Retrieves the values from the given entry_relationship.\n\n    Args:\n        entry_relationship: The entry_relationship object to extract values from.\n\n    Returns:\n        A list of values extracted from the entry_relationship.\n\n    \"\"\"\n    values = []\n    if isinstance(entry_relationship, list):\n        for item in entry_relationship:\n            if item.observation:\n                values.append(item.observation.value)\n    else:\n        if entry_relationship.observation:\n            values.append(entry_relationship.observation.value)\n    return values\n</code></pre>"},{"location":"api/cds_hooks/","title":"CDS Hooks","text":"<p>https://cds-hooks.org/specification/current/#discovery</p> <p>This is not compulsary</p> <p>https://cds-hooks.org/specification/current/#feedback</p>"},{"location":"api/cds_hooks/#healthchain.models.hooks.encounterdischarge.EncounterDischargeContext","title":"<code>EncounterDischargeContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: This hook is triggered during the discharge process for typically inpatient encounters. It can be invoked at any point from the start to the end of the discharge process. The purpose is to allow hook services to intervene in various aspects of the discharge decision. This includes verifying discharge medications, ensuring continuity of care planning, and verifying necessary documentation for discharge processing.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. The ID of the current user, expected to be a Practitioner or PractitionerRole.           For example, 'Practitioner/123'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id of the patient being discharged.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>REQUIRED. The FHIR Encounter.id of the encounter being ended.</p> <p> TYPE: <code>str</code> </p> <p>Documentation: https://cds-hooks.org/hooks/encounter-discharge/</p> Source code in <code>healthchain/models/hooks/encounterdischarge.py</code> <pre><code>class EncounterDischargeContext(BaseHookContext):\n    \"\"\"\n    Workflow:\n    This hook is triggered during the discharge process for typically inpatient encounters. It can be invoked\n    at any point from the start to the end of the discharge process. The purpose is to allow hook services to\n    intervene in various aspects of the discharge decision. This includes verifying discharge medications,\n    ensuring continuity of care planning, and verifying necessary documentation for discharge processing.\n\n    Attributes:\n        userId (str): REQUIRED. The ID of the current user, expected to be a Practitioner or PractitionerRole.\n                      For example, 'Practitioner/123'.\n        patientId (str): REQUIRED. The FHIR Patient.id of the patient being discharged.\n        encounterId (str): REQUIRED. The FHIR Encounter.id of the encounter being ended.\n\n    Documentation: https://cds-hooks.org/hooks/encounter-discharge/\n    \"\"\"\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"The ID of the current user, expected to be in the format 'Practitioner/123'.\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id of the patient being discharged.\",\n    )\n    encounterId: str = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the encounter being ended.\",\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.orderselect.OrderSelectContext","title":"<code>OrderSelectContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The order-select hook occurs after the clinician selects the order and before signing. This hook occurs when a clinician initially selects one or more new orders from a list of potential orders for a specific patient (including orders for medications, procedures, labs and other orders). The newly selected order defines that medication, procedure, lab, etc, but may or may not define the additional details necessary to finalize the order.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. An identifier of the current user, in the format [ResourceType]/[id],           where ResourceType is either 'Practitioner' or 'PractitionerRole'. Examples: 'PractitionerRole/123',           'Practitioner/abc'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>OPTIONAL. The FHIR Encounter.id representing the current encounter in context,                          if applicable.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>selections</code> <p>REQUIRED. A list of the FHIR id(s) of the newly selected orders, referencing resources                 in the draftOrders Bundle. Example: 'MedicationRequest/103'.</p> <p> TYPE: <code>[str]</code> </p> <code>draftOrders</code> <p>REQUIRED. A Bundle of FHIR request resources with a draft status, representing all unsigned                   orders from the current session, including newly selected orders.</p> <p> TYPE: <code>object</code> </p> <p>Documentation: https://cds-hooks.org/hooks/order-select/</p> Source code in <code>healthchain/models/hooks/orderselect.py</code> <pre><code>class OrderSelectContext(BaseHookContext):\n    \"\"\"\n    Workflow: The order-select hook occurs after the clinician selects the order and before signing.\n    This hook occurs when a clinician initially selects one or more new orders from a list of\n    potential orders for a specific patient (including orders for medications, procedures, labs\n    and other orders). The newly selected order defines that medication, procedure, lab, etc,\n    but may or may not define the additional details necessary to finalize the order.\n\n    Attributes:\n        userId (str): REQUIRED. An identifier of the current user, in the format [ResourceType]/[id],\n                      where ResourceType is either 'Practitioner' or 'PractitionerRole'. Examples: 'PractitionerRole/123',\n                      'Practitioner/abc'.\n        patientId (str): REQUIRED. The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): OPTIONAL. The FHIR Encounter.id representing the current encounter in context,\n                                     if applicable.\n        selections ([str]): REQUIRED. A list of the FHIR id(s) of the newly selected orders, referencing resources\n                            in the draftOrders Bundle. Example: 'MedicationRequest/103'.\n        draftOrders (object): REQUIRED. A Bundle of FHIR request resources with a draft status, representing all unsigned\n                              orders from the current session, including newly selected orders.\n\n    Documentation: https://cds-hooks.org/hooks/order-select/\n    \"\"\"\n\n    # TODO: validate selection and FHIR Bundle resource\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"An identifier of the current user in the format [ResourceType]/[id].\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id representing the current patient in context.\",\n    )\n    encounterId: Optional[str] = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the current encounter, if applicable.\",\n    )\n    selections: List[str] = Field(\n        ..., description=\"A list of the FHIR ids of the newly selected orders.\"\n    )\n    draftOrders: Dict[str, Any] = Field(\n        ..., description=\"A Bundle of FHIR request resources with a draft status.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\n            \"userId\",\n            \"patientId\",\n            \"encounterId\",\n            \"selections\",\n            \"draftOrders\",\n        }\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n\n    @model_validator(mode=\"after\")\n    def validate_selections(self) -&gt; Self:\n        for selection in self.selections:\n            if \"/\" not in selection:\n                raise ValueError(\n                    \"Each selection must be a valid FHIR resource identifier in the format 'ResourceType/ResourceID'.\"\n                )\n        return self\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.ordersign.OrderSignContext","title":"<code>OrderSignContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The order-sign hook is triggered when a clinician is ready to sign one or more orders for a patient. This includes orders for medications, procedures, labs, and other orders. It is one of the last workflow events before an order is promoted from a draft status. The context includes all order details such as dose, quantity, route, etc., even though the order is still in a draft status. This hook is also applicable for re-signing revised orders, which may have a status other than 'draft'. The hook replaces the medication-prescribe and order-review hooks.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. The ID of the current user, expected to be of type 'Practitioner' or 'PractitionerRole'.           Examples include 'PractitionerRole/123' or 'Practitioner/abc'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>OPTIONAL. The FHIR Encounter.id of the current encounter in context.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>draftOrders</code> <p>REQUIRED. A Bundle of FHIR request resources with a draft status, representing orders that                 aren't yet signed from the current ordering session.</p> <p> TYPE: <code>dict</code> </p> <p>Documentation: https://cds-hooks.org/hooks/order-sign/</p> Source code in <code>healthchain/models/hooks/ordersign.py</code> <pre><code>class OrderSignContext(BaseHookContext):\n    \"\"\"\n    Workflow:\n    The order-sign hook is triggered when a clinician is ready to sign one or more orders for a patient.\n    This includes orders for medications, procedures, labs, and other orders. It is one of the last workflow\n    events before an order is promoted from a draft status. The context includes all order details such as\n    dose, quantity, route, etc., even though the order is still in a draft status. This hook is also applicable\n    for re-signing revised orders, which may have a status other than 'draft'. The hook replaces the\n    medication-prescribe and order-review hooks.\n\n    Attributes:\n        userId (str): REQUIRED. The ID of the current user, expected to be of type 'Practitioner' or 'PractitionerRole'.\n                      Examples include 'PractitionerRole/123' or 'Practitioner/abc'.\n        patientId (str): REQUIRED. The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): OPTIONAL. The FHIR Encounter.id of the current encounter in context.\n        draftOrders (dict): REQUIRED. A Bundle of FHIR request resources with a draft status, representing orders that\n                            aren't yet signed from the current ordering session.\n\n    Documentation: https://cds-hooks.org/hooks/order-sign/\n    \"\"\"\n\n    # TODO: validate draftOrders\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"The ID of the current user in the format [ResourceType]/[id].\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id representing the current patient in context.\",\n    )\n    encounterId: Optional[str] = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the current encounter, if applicable.\",\n    )\n    draftOrders: Dict[str, Any] = Field(\n        ..., description=\"A Bundle of FHIR request resources with a draft status.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\", \"draftOrders\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.patientview.PatientViewContext","title":"<code>PatientViewContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The user has just opened a patient's record; typically called only once at the beginning of a user's interaction with a specific patient's record.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>An identifier of the current user, in the format [ResourceType]/[id],           where ResourceType is one of 'Practitioner', 'PractitionerRole', 'Patient',           or 'RelatedPerson'. Examples: 'Practitioner/abc', 'Patient/123'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>The FHIR Encounter.id representing the current encounter in context,                          if applicable. This field is optional.</p> <p> TYPE: <code>Optional[str]</code> </p> <p>Documentation: https://cds-hooks.org/hooks/patient-view/</p> Source code in <code>healthchain/models/hooks/patientview.py</code> <pre><code>class PatientViewContext(BaseHookContext):\n    \"\"\"\n    Workflow: The user has just opened a patient's record; typically called only once at the beginning of a user's\n    interaction with a specific patient's record.\n\n    Attributes:\n        userId (str): An identifier of the current user, in the format [ResourceType]/[id],\n                      where ResourceType is one of 'Practitioner', 'PractitionerRole', 'Patient',\n                      or 'RelatedPerson'. Examples: 'Practitioner/abc', 'Patient/123'.\n        patientId (str): The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): The FHIR Encounter.id representing the current encounter in context,\n                                     if applicable. This field is optional.\n\n    Documentation: https://cds-hooks.org/hooks/patient-view/\n    \"\"\"\n\n    # TODO: more comprehensive validator? for now regex should suffice\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole|Patient|RelatedPerson)/[^\\s]+$\",\n        description=\"The ID of the current user, expected to be in the format 'Practitioner/123'.\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id of the patient.\",\n    )\n    encounterId: Optional[str] = Field(\n        None, description=\"The FHIR Encounter.id of the encounter, if applicable.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsdiscovery.CDSService","title":"<code>CDSService</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A model representing a CDS service configuration.</p> ATTRIBUTE DESCRIPTION <code>hook</code> <p>The hook this service should be invoked on. This should correspond to one of the predefined hooks.</p> <p> TYPE: <code>str</code> </p> <code>title</code> <p>The human-friendly name of this service. It is recommended to provide this for better usability.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>description</code> <p>A detailed description of what this service does and its purpose within the CDS framework.</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>The unique identifier of this service. It forms part of the URL as {baseUrl}/cds-services/{id}.</p> <p> TYPE: <code>str</code> </p> <code>prefetch</code> <p>Optional FHIR queries that the service requests the CDS Client to perform                                 and provide on each service call. Keys describe the type of data and values are the actual FHIR query strings.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> </p> <code>usageRequirements</code> <p>Human-friendly description of any preconditions for the use of this CDS service.</p> <p> TYPE: <code>Optional[str]</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#response</p> Source code in <code>healthchain/models/responses/cdsdiscovery.py</code> <pre><code>class CDSService(BaseModel):\n    \"\"\"\n    A model representing a CDS service configuration.\n\n    Attributes:\n        hook (str): The hook this service should be invoked on. This should correspond to one of the predefined hooks.\n        title (Optional[str]): The human-friendly name of this service. It is recommended to provide this for better usability.\n        description (str): A detailed description of what this service does and its purpose within the CDS framework.\n        id (str): The unique identifier of this service. It forms part of the URL as {baseUrl}/cds-services/{id}.\n        prefetch (Optional[Dict[str, str]]): Optional FHIR queries that the service requests the CDS Client to perform\n                                            and provide on each service call. Keys describe the type of data and values are the actual FHIR query strings.\n        usageRequirements (Optional[str]): Human-friendly description of any preconditions for the use of this CDS service.\n\n    Documentation: https://cds-hooks.org/specification/current/#response\n    \"\"\"\n\n    hook: str\n    description: str\n    id: str\n    title: Optional[str] = None\n    prefetch: Optional[Dict[str, Any]] = None\n    usageRequirements: Optional[str] = None\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsdiscovery.CDSServiceInformation","title":"<code>CDSServiceInformation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A CDS Service is discoverable via a stable endpoint by CDS Clients. The Discovery endpoint includes information such as a description of the CDS Service, when it should be invoked, and any data that is requested to be prefetched.</p> Source code in <code>healthchain/models/responses/cdsdiscovery.py</code> <pre><code>class CDSServiceInformation(BaseModel):\n    \"\"\"\n    A CDS Service is discoverable via a stable endpoint by CDS Clients. The Discovery endpoint includes information such as a\n    description of the CDS Service, when it should be invoked, and any data that is requested to be prefetched.\n    \"\"\"\n\n    services: List[CDSService] = []\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsfeedback.CDSFeedback","title":"<code>CDSFeedback</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A feedback endpoint enables suggestion tracking &amp; analytics. A CDS Service MAY support a feedback endpoint; a CDS Client SHOULD be capable of sending feedback.</p> ATTRIBUTE DESCRIPTION <code>card</code> <p>The card.uuid from the CDS Hooks response. Uniquely identifies the card.</p> <p> TYPE: <code>str</code> </p> <code>outcome</code> <p>The outcome of the action, either 'accepted' or 'overridden'.</p> <p> TYPE: <code>str</code> </p> <code>acceptedSuggestions</code> <p>An array of accepted suggestions, required if the outcome is 'accepted'.</p> <p> TYPE: <code>List[AcceptedSuggestion]</code> </p> <code>overrideReason</code> <p>The reason for overriding, including any coding and comments.</p> <p> TYPE: <code>Optional[OverrideReason]</code> </p> <code>outcomeTimestamp</code> <p>The ISO8601 timestamp of when the action was taken on the card.</p> <p> TYPE: <code>datetime</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#feedback</p> Source code in <code>healthchain/models/responses/cdsfeedback.py</code> <pre><code>class CDSFeedback(BaseModel):\n    \"\"\"\n    A feedback endpoint enables suggestion tracking &amp; analytics.\n    A CDS Service MAY support a feedback endpoint; a CDS Client SHOULD be capable of sending feedback.\n\n    Attributes:\n        card (str): The card.uuid from the CDS Hooks response. Uniquely identifies the card.\n        outcome (str): The outcome of the action, either 'accepted' or 'overridden'.\n        acceptedSuggestions (List[AcceptedSuggestion]): An array of accepted suggestions, required if the outcome is 'accepted'.\n        overrideReason (Optional[OverrideReason]): The reason for overriding, including any coding and comments.\n        outcomeTimestamp (datetime): The ISO8601 timestamp of when the action was taken on the card.\n\n    Documentation: https://cds-hooks.org/specification/current/#feedback\n    \"\"\"\n\n    card: str\n    outcome: OutcomeEnum\n    outcomeTimestamp: str\n    acceptedSuggestion: Optional[Dict[str, Any]] = None\n    overriddeReason: Optional[OverrideReason] = None\n</code></pre>"},{"location":"api/clients/","title":"Clients","text":""},{"location":"api/clients/#healthchain.clients.ehrclient.EHRClient","title":"<code>EHRClient</code>","text":"<p>               Bases: <code>BaseClient</code></p> Source code in <code>healthchain/clients/ehrclient.py</code> <pre><code>class EHRClient(BaseClient):\n    def __init__(\n        self,\n        func: Callable[..., Any],\n        workflow: Workflow,\n        strategy: BaseStrategy,\n        timeout: Optional[float] = 10.0,\n    ):\n        \"\"\"\n        Initializes the EHRClient with a data generator function and optional workflow and use case.\n        Should be a subclass of BaseUseCase. Example - ClinicalDecisionSupport()\n\n        Parameters:\n            func (Callable[..., Any]): A function to generate data for requests.\n            workflow ([Workflow]): The workflow context to apply to the data generator.\n            strategy (BaseStrategy): The strategy object to construct requests based on the generated data.\n            timeout(Optional[float], default=10.0) : The maximum time in seconds to wait for a response from the server.\n            This parameter determines how long the client will wait before considering a request timed out.\n            A higher timeout value allows for longer-running operations, while a lower value prioritizes faster responses.\n        \"\"\"\n        # TODO: Add option to pass in different provider options\n        self.data_generator_func: Callable[..., Any] = func\n        self.workflow: Workflow = workflow\n        self.strategy: BaseStrategy = strategy\n        self.vendor = None\n        self.request_data: List[CDSRequest] = []\n        self.timeout = timeout\n\n    def set_vendor(self, name) -&gt; None:\n        self.vendor = name\n\n    def generate_request(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Generates a request using the data produced by the data generator function,\n        and appends it to the internal request queue.\n\n            Parameters:\n                *args (Any): Positional arguments passed to the data generator function.\n                **kwargs (Any): Keyword arguments passed to the data generator function.\n\n            Raises:\n                ValueError: If the use case is not configured.\n        \"\"\"\n        data = self.data_generator_func(*args, **kwargs)\n        self.request_data.append(self.strategy.construct_request(data, self.workflow))\n\n    async def send_request(self, url: str) -&gt; List[Dict]:\n        \"\"\"\n        Sends all queued requests to the specified URL and collects the responses.\n\n            Parameters:\n                url (str): The URL to which the requests will be sent.\n            Returns:\n                List[dict]: A list of JSON responses from the server.\n            Notes:\n                This method logs errors rather than raising them, to avoid interrupting the batch processing of requests.\n        \"\"\"\n        async with httpx.AsyncClient() as client:\n            responses: List[Dict] = []\n            # TODO: pass timeout as config\n            timeout = httpx.Timeout(self.timeout, read=None)\n            for request in self.request_data:\n                try:\n                    if self.strategy.api_protocol == ApiProtocol.soap:\n                        headers = {\"Content-Type\": \"text/xml; charset=utf-8\"}\n                        response = await client.post(\n                            url=url,\n                            data=request.document,\n                            headers=headers,\n                            timeout=timeout,\n                        )\n                        response.raise_for_status()\n                        response_model = CdaResponse(document=response.text)\n                        responses.append(response_model.model_dump_xml())\n                    else:\n                        response = await client.post(\n                            url=url,\n                            json=request.model_dump(exclude_none=True),\n                            timeout=timeout,\n                        )\n                        response.raise_for_status()\n                        responses.append(response.json())\n                except httpx.HTTPStatusError as exc:\n                    log.error(\n                        f\"Error response {exc.response.status_code} while requesting {exc.request.url!r}.\"\n                    )\n                    responses.append({})\n                except httpx.TimeoutException as exc:\n                    log.error(f\"Request to {exc.request.url!r} timed out!\")\n                    responses.append({})\n                except httpx.RequestError as exc:\n                    log.error(\n                        f\"An error occurred while requesting {exc.request.url!r}.\"\n                    )\n                    responses.append({})\n\n        return responses\n</code></pre>"},{"location":"api/clients/#healthchain.clients.ehrclient.EHRClient.__init__","title":"<code>__init__(func, workflow, strategy, timeout=10.0)</code>","text":"<p>Initializes the EHRClient with a data generator function and optional workflow and use case. Should be a subclass of BaseUseCase. Example - ClinicalDecisionSupport()</p> PARAMETER DESCRIPTION <code>func</code> <p>A function to generate data for requests.</p> <p> TYPE: <code>Callable[..., Any]</code> </p> <code>workflow</code> <p>The workflow context to apply to the data generator.</p> <p> TYPE: <code>[Workflow]</code> </p> <code>strategy</code> <p>The strategy object to construct requests based on the generated data.</p> <p> TYPE: <code>BaseStrategy</code> </p> <code>timeout(Optional[float],</code> <p>The maximum time in seconds to wait for a response from the server.</p> <p> TYPE: <code>default=10.0) </code> </p> Source code in <code>healthchain/clients/ehrclient.py</code> <pre><code>def __init__(\n    self,\n    func: Callable[..., Any],\n    workflow: Workflow,\n    strategy: BaseStrategy,\n    timeout: Optional[float] = 10.0,\n):\n    \"\"\"\n    Initializes the EHRClient with a data generator function and optional workflow and use case.\n    Should be a subclass of BaseUseCase. Example - ClinicalDecisionSupport()\n\n    Parameters:\n        func (Callable[..., Any]): A function to generate data for requests.\n        workflow ([Workflow]): The workflow context to apply to the data generator.\n        strategy (BaseStrategy): The strategy object to construct requests based on the generated data.\n        timeout(Optional[float], default=10.0) : The maximum time in seconds to wait for a response from the server.\n        This parameter determines how long the client will wait before considering a request timed out.\n        A higher timeout value allows for longer-running operations, while a lower value prioritizes faster responses.\n    \"\"\"\n    # TODO: Add option to pass in different provider options\n    self.data_generator_func: Callable[..., Any] = func\n    self.workflow: Workflow = workflow\n    self.strategy: BaseStrategy = strategy\n    self.vendor = None\n    self.request_data: List[CDSRequest] = []\n    self.timeout = timeout\n</code></pre>"},{"location":"api/clients/#healthchain.clients.ehrclient.EHRClient.generate_request","title":"<code>generate_request(*args, **kwargs)</code>","text":"<p>Generates a request using the data produced by the data generator function, and appends it to the internal request queue.</p> <pre><code>Parameters:\n    *args (Any): Positional arguments passed to the data generator function.\n    **kwargs (Any): Keyword arguments passed to the data generator function.\n\nRaises:\n    ValueError: If the use case is not configured.\n</code></pre> Source code in <code>healthchain/clients/ehrclient.py</code> <pre><code>def generate_request(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Generates a request using the data produced by the data generator function,\n    and appends it to the internal request queue.\n\n        Parameters:\n            *args (Any): Positional arguments passed to the data generator function.\n            **kwargs (Any): Keyword arguments passed to the data generator function.\n\n        Raises:\n            ValueError: If the use case is not configured.\n    \"\"\"\n    data = self.data_generator_func(*args, **kwargs)\n    self.request_data.append(self.strategy.construct_request(data, self.workflow))\n</code></pre>"},{"location":"api/clients/#healthchain.clients.ehrclient.EHRClient.send_request","title":"<code>send_request(url)</code>  <code>async</code>","text":"<p>Sends all queued requests to the specified URL and collects the responses.</p> <pre><code>Parameters:\n    url (str): The URL to which the requests will be sent.\nReturns:\n    List[dict]: A list of JSON responses from the server.\nNotes:\n    This method logs errors rather than raising them, to avoid interrupting the batch processing of requests.\n</code></pre> Source code in <code>healthchain/clients/ehrclient.py</code> <pre><code>async def send_request(self, url: str) -&gt; List[Dict]:\n    \"\"\"\n    Sends all queued requests to the specified URL and collects the responses.\n\n        Parameters:\n            url (str): The URL to which the requests will be sent.\n        Returns:\n            List[dict]: A list of JSON responses from the server.\n        Notes:\n            This method logs errors rather than raising them, to avoid interrupting the batch processing of requests.\n    \"\"\"\n    async with httpx.AsyncClient() as client:\n        responses: List[Dict] = []\n        # TODO: pass timeout as config\n        timeout = httpx.Timeout(self.timeout, read=None)\n        for request in self.request_data:\n            try:\n                if self.strategy.api_protocol == ApiProtocol.soap:\n                    headers = {\"Content-Type\": \"text/xml; charset=utf-8\"}\n                    response = await client.post(\n                        url=url,\n                        data=request.document,\n                        headers=headers,\n                        timeout=timeout,\n                    )\n                    response.raise_for_status()\n                    response_model = CdaResponse(document=response.text)\n                    responses.append(response_model.model_dump_xml())\n                else:\n                    response = await client.post(\n                        url=url,\n                        json=request.model_dump(exclude_none=True),\n                        timeout=timeout,\n                    )\n                    response.raise_for_status()\n                    responses.append(response.json())\n            except httpx.HTTPStatusError as exc:\n                log.error(\n                    f\"Error response {exc.response.status_code} while requesting {exc.request.url!r}.\"\n                )\n                responses.append({})\n            except httpx.TimeoutException as exc:\n                log.error(f\"Request to {exc.request.url!r} timed out!\")\n                responses.append({})\n            except httpx.RequestError as exc:\n                log.error(\n                    f\"An error occurred while requesting {exc.request.url!r}.\"\n                )\n                responses.append({})\n\n    return responses\n</code></pre>"},{"location":"api/clients/#healthchain.clients.ehrclient.ehr","title":"<code>ehr(func=None, *, workflow, num=1)</code>","text":"<p>A decorator that wraps around a data generator function and returns an EHRClient</p> PARAMETER DESCRIPTION <code>func</code> <p>The function to be decorated. If None, this allows the decorator to                        be used with arguments.</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>workflow</code> <p>The workflow identifier which should match an item in the Workflow enum.                       This specifies the context in which the EHR function will operate.</p> <p> TYPE: <code>[str]</code> </p> <code>num</code> <p>The number of requests to generate in the queue; defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A decorated callable that incorporates EHR functionality or the decorator itself       if 'func' is None, allowing it to be used as a parameterized decorator.</p> <p> TYPE: <code>Union[Callable[..., Any], Callable[[F], F]]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the workflow does not correspond to any defined enum or if use case is not configured.</p> <code>NotImplementedError</code> <p>If the use case class is not one of the supported types.</p> Example <p>@ehr(workflow='patient-view', num=2) def generate_data(self, config):     # Function implementation</p> Source code in <code>healthchain/clients/ehrclient.py</code> <pre><code>def ehr(\n    func: Optional[F] = None, *, workflow: Workflow, num: int = 1\n) -&gt; Union[Callable[..., Any], Callable[[F], F]]:\n    \"\"\"\n    A decorator that wraps around a data generator function and returns an EHRClient\n\n    Parameters:\n        func (Optional[Callable]): The function to be decorated. If None, this allows the decorator to\n                                   be used with arguments.\n        workflow ([str]): The workflow identifier which should match an item in the Workflow enum.\n                                  This specifies the context in which the EHR function will operate.\n        num (int): The number of requests to generate in the queue; defaults to 1.\n\n    Returns:\n        Callable: A decorated callable that incorporates EHR functionality or the decorator itself\n                  if 'func' is None, allowing it to be used as a parameterized decorator.\n\n    Raises:\n        ValueError: If the workflow does not correspond to any defined enum or if use case is not configured.\n        NotImplementedError: If the use case class is not one of the supported types.\n\n    Example:\n        @ehr(workflow='patient-view', num=2)\n        def generate_data(self, config):\n            # Function implementation\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        func.is_client = True\n\n        @wraps(func)\n        def wrapper(self, *args: Any, **kwargs: Any) -&gt; EHRClient:\n            # Validate function decorated is a use case base class\n            assert issubclass(\n                type(self), BaseUseCase\n            ), f\"{self.__class__.__name__} must be subclass of valid Use Case strategy!\"\n\n            # Validate workflow is a valid workflow\n            try:\n                workflow_enum = Workflow(workflow)\n            except ValueError as e:\n                raise ValueError(\n                    f\"{e}: please select from {[x.value for x in Workflow]}\"\n                )\n\n            # Set workflow in data generator if configured\n            data_generator_attributes = find_attributes_of_type(self, CdsDataGenerator)\n            for i in range(len(data_generator_attributes)):\n                attribute_name = data_generator_attributes[i]\n                try:\n                    assign_to_attribute(\n                        self, attribute_name, \"set_workflow\", workflow_enum\n                    )\n                except Exception as e:\n                    log.error(\n                        f\"Could not set workflow {workflow_enum.value} for data generator method {attribute_name}: {e}\"\n                    )\n                if i &gt; 1:\n                    log.warning(\"More than one DataGenerator instances found.\")\n\n            # Wrap the function in EHRClient with workflow and strategy passed in\n            if self.type in UseCaseType:\n                method = EHRClient(func, workflow=workflow_enum, strategy=self.strategy)\n                # Generate the number of requests specified with method\n                for _ in range(num):\n                    method.generate_request(self, *args, **kwargs)\n            else:\n                raise NotImplementedError(\n                    f\"Use case {self.type} not recognised, check if implemented.\"\n                )\n            return method\n\n        return wrapper\n\n    if func is None:\n        return decorator\n    else:\n        return decorator(func)\n</code></pre>"},{"location":"api/component/","title":"Component","text":""},{"location":"api/component/#healthchain.pipeline.components.base.BaseComponent","title":"<code>BaseComponent</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract base class for all components in the pipeline.</p> <p>This class should be subclassed to create specific components. Subclasses must implement the call method.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>class BaseComponent(Generic[T], ABC):\n    \"\"\"\n    Abstract base class for all components in the pipeline.\n\n    This class should be subclassed to create specific components.\n    Subclasses must implement the __call__ method.\n\n    Attributes:\n        None\n    \"\"\"\n\n    @abstractmethod\n    def __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        \"\"\"\n        Process the input data and return the processed data.\n\n        Args:\n            data (DataContainer[T]): The input data to be processed.\n\n        Returns:\n            DataContainer[T]: The processed data.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.base.BaseComponent.__call__","title":"<code>__call__(data)</code>  <code>abstractmethod</code>","text":"<p>Process the input data and return the processed data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The input data to be processed.</p> <p> TYPE: <code>DataContainer[T]</code> </p> RETURNS DESCRIPTION <code>DataContainer[T]</code> <p>DataContainer[T]: The processed data.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>@abstractmethod\ndef __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n    \"\"\"\n    Process the input data and return the processed data.\n\n    Args:\n        data (DataContainer[T]): The input data to be processed.\n\n    Returns:\n        DataContainer[T]: The processed data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.base.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>BaseComponent[T]</code></p> <p>A concrete implementation of the BaseComponent class.</p> <p>This class can be used as a base for creating specific components that do not require any additional processing logic.</p> METHOD DESCRIPTION <code>__call__</code> <p>DataContainer[T]) -&gt; DataContainer[T]: Process the input data and return the processed data. In this implementation, the input data is returned unmodified.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>class Component(BaseComponent[T]):\n    \"\"\"\n    A concrete implementation of the BaseComponent class.\n\n    This class can be used as a base for creating specific components\n    that do not require any additional processing logic.\n\n    Methods:\n        __call__(data: DataContainer[T]) -&gt; DataContainer[T]:\n            Process the input data and return the processed data.\n            In this implementation, the input data is returned unmodified.\n    \"\"\"\n\n    def __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        return data\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor","title":"<code>TextPreProcessor</code>","text":"<p>               Bases: <code>BaseComponent[Document]</code></p> <p>A component for preprocessing text documents.</p> <p>This class applies various cleaning and tokenization steps to a Document object, based on the provided configuration.</p> ATTRIBUTE DESCRIPTION <code>tokenizer</code> <p>The tokenizer to use. Defaults to \"basic\".</p> <p> TYPE: <code>str</code> </p> <code>lowercase</code> <p>Whether to convert text to lowercase. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>remove_punctuation</code> <p>Whether to remove punctuation. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>standardize_spaces</code> <p>Whether to standardize spaces. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>regex</code> <p>List of regex patterns and replacements. Defaults to an empty list.</p> <p> TYPE: <code>List[Tuple[str, str]]</code> </p> <code>tokenizer_func</code> <p>The tokenization function.</p> <p> TYPE: <code>Callable[[str], List[str]]</code> </p> <code>cleaning_steps</code> <p>List of text cleaning functions.</p> <p> TYPE: <code>List[Callable[[str], str]]</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>class TextPreProcessor(BaseComponent[Document]):\n    \"\"\"\n    A component for preprocessing text documents.\n\n    This class applies various cleaning and tokenization steps to a Document object,\n    based on the provided configuration.\n\n    Attributes:\n        tokenizer (str): The tokenizer to use. Defaults to \"basic\".\n        lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n        remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n        standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n        regex (List[Tuple[str, str]]): List of regex patterns and replacements. Defaults to an empty list.\n        tokenizer_func (Callable[[str], List[str]]): The tokenization function.\n        cleaning_steps (List[Callable[[str], str]]): List of text cleaning functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        tokenizer: str = \"basic\",\n        lowercase: bool = False,\n        remove_punctuation: bool = False,\n        standardize_spaces: bool = False,\n        regex: List[Tuple[str, str]] = None,\n    ):\n        \"\"\"\n        Initialize the TextPreprocessor with the given configuration.\n\n        Args:\n            tokenizer (str): The tokenizer to use. Defaults to \"basic\".\n            lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n            remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n            standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n            regex (List[Tuple[str, str]], optional): List of regex patterns and replacements. Defaults to None.\n        \"\"\"\n        self.lowercase = lowercase\n        self.remove_punctuation = remove_punctuation\n        self.standardize_spaces = standardize_spaces\n        self.regex = regex or []\n        self.tokenizer = self._get_tokenizer(tokenizer)\n        self.cleaning_steps = self._configure_cleaning_steps()\n\n    def _get_tokenizer(self, tokenizer: str) -&gt; Callable[[str], List[str]]:\n        \"\"\"\n        Get the tokenization function based on the specified tokenizer.\n\n        Args:\n            tokenizer (str): The name of the tokenizer to use.\n\n        Returns:\n            Callable[[str], List[str]]: The tokenization function.\n\n        Raises:\n            ValueError: If an unsupported tokenizer is specified.\n            ImportError: If the spacy tokenizer is requested but not installed.\n        \"\"\"\n        # TODO: test import errors\n        if tokenizer == \"basic\":\n            return lambda text: text.split()\n        elif tokenizer == \"spacy\":\n            try:\n                import spacy\n\n                nlp = spacy.load(\"en_core_web_sm\")\n            except (ImportError, OSError):\n                raise ImportError(\n                    \"To use the spacy tokenizer, please install spaCy and download the English model:\\n\"\n                    \"1. pip install spacy\\n\"\n                    \"2. python -m spacy download en_core_web_sm\"\n                )\n            return lambda text: [token.text for token in nlp(text)]\n        else:\n            raise ValueError(f\"Unsupported tokenizer: {tokenizer}\")\n\n    def _configure_cleaning_steps(self) -&gt; List[Callable[[str], str]]:\n        \"\"\"\n        Configure the text cleaning steps based on the preprocessor configuration.\n\n        Returns:\n            List[Callable[[str], str]]: List of text cleaning functions.\n        \"\"\"\n        steps = []\n        if self.lowercase:\n            steps.append(lambda text: text.lower())\n\n        regex_steps = []\n        if self.regex:\n            regex_steps.extend(self.regex)\n        else:\n            if self.remove_punctuation:\n                regex_steps.append((r\"[^\\w\\s]\", \"\"))\n            if self.standardize_spaces:\n                regex_steps.append((r\"\\s+\", \" \"))\n\n        for pattern, repl in regex_steps:\n            steps.append(self._create_regex_step(pattern, repl))\n\n        if self.standardize_spaces:\n            steps.append(str.strip)\n\n        return steps\n\n    @staticmethod\n    def _create_regex_step(pattern: str, repl: str) -&gt; Callable[[str], str]:\n        \"\"\"\n        Create a regex-based cleaning step. This can be used in place of other cleaning steps, if required.\n\n        Args:\n            pattern (str): The regex pattern to match.\n            repl (str): The replacement string.\n\n        Returns:\n            Callable[[str], str]: A function that applies the regex substitution.\n        \"\"\"\n        return lambda text: re.sub(pattern, repl, text)\n\n    def _clean_text(self, text: str) -&gt; str:\n        \"\"\"\n        Apply all cleaning steps to the input text.\n\n        Args:\n            text (str): The input text to clean.\n\n        Returns:\n            str: The cleaned text.\n        \"\"\"\n        for step in self.cleaning_steps:\n            text = step(text)\n        return text\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"\n        Preprocess the given Document.\n\n        This method applies the configured cleaning steps and tokenization to the document's text (in that order).\n\n        Args:\n            doc (Document): The document to preprocess.\n\n        Returns:\n            Document: The preprocessed document with updated tokens and preprocessed text.\n        \"\"\"\n        # Preprocess text\n        preprocessed_text = self._clean_text(doc.text)\n        doc.preprocessed_text = preprocessed_text\n\n        # Tokenize\n        tokens = self.tokenizer(preprocessed_text)\n\n        # Update document\n        doc.tokens = tokens\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor.__call__","title":"<code>__call__(doc)</code>","text":"<p>Preprocess the given Document.</p> <p>This method applies the configured cleaning steps and tokenization to the document's text (in that order).</p> PARAMETER DESCRIPTION <code>doc</code> <p>The document to preprocess.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>The preprocessed document with updated tokens and preprocessed text.</p> <p> TYPE: <code>Document</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"\n    Preprocess the given Document.\n\n    This method applies the configured cleaning steps and tokenization to the document's text (in that order).\n\n    Args:\n        doc (Document): The document to preprocess.\n\n    Returns:\n        Document: The preprocessed document with updated tokens and preprocessed text.\n    \"\"\"\n    # Preprocess text\n    preprocessed_text = self._clean_text(doc.text)\n    doc.preprocessed_text = preprocessed_text\n\n    # Tokenize\n    tokens = self.tokenizer(preprocessed_text)\n\n    # Update document\n    doc.tokens = tokens\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor.__init__","title":"<code>__init__(tokenizer='basic', lowercase=False, remove_punctuation=False, standardize_spaces=False, regex=None)</code>","text":"<p>Initialize the TextPreprocessor with the given configuration.</p> PARAMETER DESCRIPTION <code>tokenizer</code> <p>The tokenizer to use. Defaults to \"basic\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'basic'</code> </p> <code>lowercase</code> <p>Whether to convert text to lowercase. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>remove_punctuation</code> <p>Whether to remove punctuation. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>standardize_spaces</code> <p>Whether to standardize spaces. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>regex</code> <p>List of regex patterns and replacements. Defaults to None.</p> <p> TYPE: <code>List[Tuple[str, str]]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: str = \"basic\",\n    lowercase: bool = False,\n    remove_punctuation: bool = False,\n    standardize_spaces: bool = False,\n    regex: List[Tuple[str, str]] = None,\n):\n    \"\"\"\n    Initialize the TextPreprocessor with the given configuration.\n\n    Args:\n        tokenizer (str): The tokenizer to use. Defaults to \"basic\".\n        lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n        remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n        standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n        regex (List[Tuple[str, str]], optional): List of regex patterns and replacements. Defaults to None.\n    \"\"\"\n    self.lowercase = lowercase\n    self.remove_punctuation = remove_punctuation\n    self.standardize_spaces = standardize_spaces\n    self.regex = regex or []\n    self.tokenizer = self._get_tokenizer(tokenizer)\n    self.cleaning_steps = self._configure_cleaning_steps()\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor","title":"<code>TextPostProcessor</code>","text":"<p>               Bases: <code>BaseComponent[Document]</code></p> <p>A component for post-processing text documents, specifically for refining entities.</p> <p>This class applies post-coordination rules to entities in a Document object, replacing entities with their refined versions based on a lookup dictionary.</p> ATTRIBUTE DESCRIPTION <code>entity_lookup</code> <p>A dictionary for entity refinement lookups.</p> <p> TYPE: <code>Dict[str, str]</code> </p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>class TextPostProcessor(BaseComponent[Document]):\n    \"\"\"\n    A component for post-processing text documents, specifically for refining entities.\n\n    This class applies post-coordination rules to entities in a Document object,\n    replacing entities with their refined versions based on a lookup dictionary.\n\n    Attributes:\n        entity_lookup (Dict[str, str]): A dictionary for entity refinement lookups.\n    \"\"\"\n\n    def __init__(self, postcoordination_lookup: Dict[str, str] = None):\n        \"\"\"\n        Initialize the TextPostProcessor with an optional postcoordination lookup.\n\n        Args:\n            postcoordination_lookup (Dict[str, str], optional): A dictionary for entity refinement lookups.\n                If not provided, an empty dictionary will be used.\n        \"\"\"\n        self.entity_lookup = postcoordination_lookup or {}\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"\n        Apply post-processing to the given Document.\n\n        This method refines the entities in the document based on the entity_lookup.\n        If an entity exists in the lookup, it is replaced with its refined version.\n\n        Args:\n            doc (Document): The document to be post-processed.\n\n        Returns:\n            Document: The post-processed document with refined entities.\n\n        Note:\n            If the entity_lookup is empty or the document has no 'entities' attribute,\n            the document is returned unchanged.\n        \"\"\"\n        if not self.entity_lookup or not hasattr(doc, \"entities\"):\n            return doc\n\n        refined_entities = []\n        for entity in doc.get_entities():\n            entity_text = entity[\"text\"]\n            if entity_text in self.entity_lookup:\n                entity[\"text\"] = self.entity_lookup[entity_text]\n            refined_entities.append(entity)\n\n        doc.entities = refined_entities\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor.__call__","title":"<code>__call__(doc)</code>","text":"<p>Apply post-processing to the given Document.</p> <p>This method refines the entities in the document based on the entity_lookup. If an entity exists in the lookup, it is replaced with its refined version.</p> PARAMETER DESCRIPTION <code>doc</code> <p>The document to be post-processed.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>The post-processed document with refined entities.</p> <p> TYPE: <code>Document</code> </p> Note <p>If the entity_lookup is empty or the document has no 'entities' attribute, the document is returned unchanged.</p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"\n    Apply post-processing to the given Document.\n\n    This method refines the entities in the document based on the entity_lookup.\n    If an entity exists in the lookup, it is replaced with its refined version.\n\n    Args:\n        doc (Document): The document to be post-processed.\n\n    Returns:\n        Document: The post-processed document with refined entities.\n\n    Note:\n        If the entity_lookup is empty or the document has no 'entities' attribute,\n        the document is returned unchanged.\n    \"\"\"\n    if not self.entity_lookup or not hasattr(doc, \"entities\"):\n        return doc\n\n    refined_entities = []\n    for entity in doc.get_entities():\n        entity_text = entity[\"text\"]\n        if entity_text in self.entity_lookup:\n            entity[\"text\"] = self.entity_lookup[entity_text]\n        refined_entities.append(entity)\n\n    doc.entities = refined_entities\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor.__init__","title":"<code>__init__(postcoordination_lookup=None)</code>","text":"<p>Initialize the TextPostProcessor with an optional postcoordination lookup.</p> PARAMETER DESCRIPTION <code>postcoordination_lookup</code> <p>A dictionary for entity refinement lookups. If not provided, an empty dictionary will be used.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>def __init__(self, postcoordination_lookup: Dict[str, str] = None):\n    \"\"\"\n    Initialize the TextPostProcessor with an optional postcoordination lookup.\n\n    Args:\n        postcoordination_lookup (Dict[str, str], optional): A dictionary for entity refinement lookups.\n            If not provided, an empty dictionary will be used.\n    \"\"\"\n    self.entity_lookup = postcoordination_lookup or {}\n</code></pre>"},{"location":"api/connectors/","title":"Connectors","text":""},{"location":"api/connectors/#healthchain.io.base.BaseConnector","title":"<code>BaseConnector</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract base class for all connectors in the pipeline.</p> <p>This class should be subclassed to create specific connectors. Subclasses must implement the input and output methods.</p> Source code in <code>healthchain/io/base.py</code> <pre><code>class BaseConnector(Generic[T], ABC):\n    \"\"\"\n    Abstract base class for all connectors in the pipeline.\n\n    This class should be subclassed to create specific connectors.\n    Subclasses must implement the input and output methods.\n    \"\"\"\n\n    @abstractmethod\n    def input(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        \"\"\"\n        Convert input data to the pipeline's internal format.\n\n        Args:\n            data (DataContainer[T]): The input data to be converted.\n\n        Returns:\n            DataContainer[T]: The converted data.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def output(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        \"\"\"\n        Convert pipeline's internal format to output data.\n\n        Args:\n            data (DataContainer[T]): The data to be converted for output.\n\n        Returns:\n            DataContainer[T]: The converted output data.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/connectors/#healthchain.io.base.BaseConnector.input","title":"<code>input(data)</code>  <code>abstractmethod</code>","text":"<p>Convert input data to the pipeline's internal format.</p> PARAMETER DESCRIPTION <code>data</code> <p>The input data to be converted.</p> <p> TYPE: <code>DataContainer[T]</code> </p> RETURNS DESCRIPTION <code>DataContainer[T]</code> <p>DataContainer[T]: The converted data.</p> Source code in <code>healthchain/io/base.py</code> <pre><code>@abstractmethod\ndef input(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n    \"\"\"\n    Convert input data to the pipeline's internal format.\n\n    Args:\n        data (DataContainer[T]): The input data to be converted.\n\n    Returns:\n        DataContainer[T]: The converted data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/connectors/#healthchain.io.base.BaseConnector.output","title":"<code>output(data)</code>  <code>abstractmethod</code>","text":"<p>Convert pipeline's internal format to output data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be converted for output.</p> <p> TYPE: <code>DataContainer[T]</code> </p> RETURNS DESCRIPTION <code>DataContainer[T]</code> <p>DataContainer[T]: The converted output data.</p> Source code in <code>healthchain/io/base.py</code> <pre><code>@abstractmethod\ndef output(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n    \"\"\"\n    Convert pipeline's internal format to output data.\n\n    Args:\n        data (DataContainer[T]): The data to be converted for output.\n\n    Returns:\n        DataContainer[T]: The converted output data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdaconnector.CdaConnector","title":"<code>CdaConnector</code>","text":"<p>               Bases: <code>BaseConnector</code></p> <p>CDAConnector class for handling CDA (Clinical Document Architecture) documents.</p> <p>This connector is responsible for parsing CDA documents, extracting relevant clinical data, and updating the document with new information. It serves as both an input and output connector in the pipeline.</p> ATTRIBUTE DESCRIPTION <code>overwrite</code> <p>Flag to determine if existing data should be overwritten               when updating the CDA document.</p> <p> TYPE: <code>bool</code> </p> <code>cda_doc</code> <p>The parsed CDA document.</p> <p> TYPE: <code>CdaAnnotator</code> </p> METHOD DESCRIPTION <code>input</code> <p>Parses the input CDA document and extracts clinical data.</p> <code>output</code> <p>Updates the CDA document with new data and returns the response.</p> Source code in <code>healthchain/io/cdaconnector.py</code> <pre><code>class CdaConnector(BaseConnector):\n    \"\"\"\n    CDAConnector class for handling CDA (Clinical Document Architecture) documents.\n\n    This connector is responsible for parsing CDA documents, extracting relevant\n    clinical data, and updating the document with new information. It serves as\n    both an input and output connector in the pipeline.\n\n    Attributes:\n        overwrite (bool): Flag to determine if existing data should be overwritten\n                          when updating the CDA document.\n        cda_doc (CdaAnnotator): The parsed CDA document.\n\n    Methods:\n        input: Parses the input CDA document and extracts clinical data.\n        output: Updates the CDA document with new data and returns the response.\n    \"\"\"\n\n    def __init__(self, overwrite: bool = False):\n        self.overwrite = overwrite\n        self.cda_doc = None\n\n    def input(self, in_data: CdaRequest) -&gt; Document:\n        \"\"\"\n        Parse the input CDA document and extract clinical data.\n\n        This method takes a CdaRequest object containing the CDA document as input,\n        parses it using the CdaAnnotator, and extracts relevant clinical data.\n        The extracted data is then used to create a CcdData object and a healthchain\n        Document object, which is returned.\n\n        Args:\n            in_data (CdaRequest): The input request containing the CDA document.\n\n        Returns:\n            Document: A Document object containing the extracted clinical data\n                      and the original note text.\n\n        \"\"\"\n        self.cda_doc = CdaAnnotator.from_xml(in_data.document)\n\n        # TODO: Temporary fix for the note section, this might be more of a concern for the Annotator class\n        if isinstance(self.cda_doc.note, dict):\n            note_text = \" \".join(str(value) for value in self.cda_doc.note.values())\n        elif isinstance(self.cda_doc.note, str):\n            note_text = self.cda_doc.note\n        else:\n            log.warning(\"Note section is not a string or dictionary\")\n            note_text = \"\"\n\n        ccd_data = CcdData(\n            problems=self.cda_doc.problem_list,\n            medications=self.cda_doc.medication_list,\n            allergies=self.cda_doc.allergy_list,\n            note=note_text,\n        )\n\n        return Document(data=ccd_data.note, ccd_data=ccd_data)\n\n    def output(self, out_data: Document) -&gt; CdaResponse:\n        \"\"\"\n        Update the CDA document with new data and return the response.\n\n        This method takes a Document object containing updated clinical data,\n        updates the CDA document with this new information, and returns a\n        CdaResponse object with the updated CDA document.\n\n        Args:\n            out_data (Document): A Document object containing the updated\n                                 clinical data (problems, allergies, medications).\n\n        Returns:\n            CdaResponse: A response object containing the updated CDA document.\n\n        Note:\n            The method updates the CDA document with new problems, allergies,\n            and medications if they are present in the input Document object.\n            The update behavior (overwrite or append) is determined by the\n            `overwrite` attribute of the CdaConnector instance.\n        \"\"\"\n        # Update the CDA document with the results\n        if out_data.ccd_data.problems:\n            log.debug(\n                f\"Updating CDA document with {len(out_data.ccd_data.problems)} problem(s).\"\n            )\n            self.cda_doc.add_to_problem_list(\n                out_data.ccd_data.problems, overwrite=self.overwrite\n            )\n        if out_data.ccd_data.allergies:\n            log.debug(\n                f\"Updating CDA document with {len(out_data.ccd_data.allergies)} allergy(ies).\"\n            )\n            self.cda_doc.add_to_allergy_list(\n                out_data.ccd_data.allergies, overwrite=self.overwrite\n            )\n        if out_data.ccd_data.medications:\n            log.debug(\n                f\"Updating CDA document with {len(out_data.ccd_data.medications)} medication(s).\"\n            )\n            self.cda_doc.add_to_medication_list(\n                out_data.ccd_data.medications, overwrite=self.overwrite\n            )\n\n        # Export the updated CDA document\n        response_document = self.cda_doc.export()\n\n        return CdaResponse(document=response_document)\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdaconnector.CdaConnector.input","title":"<code>input(in_data)</code>","text":"<p>Parse the input CDA document and extract clinical data.</p> <p>This method takes a CdaRequest object containing the CDA document as input, parses it using the CdaAnnotator, and extracts relevant clinical data. The extracted data is then used to create a CcdData object and a healthchain Document object, which is returned.</p> PARAMETER DESCRIPTION <code>in_data</code> <p>The input request containing the CDA document.</p> <p> TYPE: <code>CdaRequest</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>A Document object containing the extracted clinical data       and the original note text.</p> <p> TYPE: <code>Document</code> </p> Source code in <code>healthchain/io/cdaconnector.py</code> <pre><code>def input(self, in_data: CdaRequest) -&gt; Document:\n    \"\"\"\n    Parse the input CDA document and extract clinical data.\n\n    This method takes a CdaRequest object containing the CDA document as input,\n    parses it using the CdaAnnotator, and extracts relevant clinical data.\n    The extracted data is then used to create a CcdData object and a healthchain\n    Document object, which is returned.\n\n    Args:\n        in_data (CdaRequest): The input request containing the CDA document.\n\n    Returns:\n        Document: A Document object containing the extracted clinical data\n                  and the original note text.\n\n    \"\"\"\n    self.cda_doc = CdaAnnotator.from_xml(in_data.document)\n\n    # TODO: Temporary fix for the note section, this might be more of a concern for the Annotator class\n    if isinstance(self.cda_doc.note, dict):\n        note_text = \" \".join(str(value) for value in self.cda_doc.note.values())\n    elif isinstance(self.cda_doc.note, str):\n        note_text = self.cda_doc.note\n    else:\n        log.warning(\"Note section is not a string or dictionary\")\n        note_text = \"\"\n\n    ccd_data = CcdData(\n        problems=self.cda_doc.problem_list,\n        medications=self.cda_doc.medication_list,\n        allergies=self.cda_doc.allergy_list,\n        note=note_text,\n    )\n\n    return Document(data=ccd_data.note, ccd_data=ccd_data)\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdaconnector.CdaConnector.output","title":"<code>output(out_data)</code>","text":"<p>Update the CDA document with new data and return the response.</p> <p>This method takes a Document object containing updated clinical data, updates the CDA document with this new information, and returns a CdaResponse object with the updated CDA document.</p> PARAMETER DESCRIPTION <code>out_data</code> <p>A Document object containing the updated                  clinical data (problems, allergies, medications).</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>CdaResponse</code> <p>A response object containing the updated CDA document.</p> <p> TYPE: <code>CdaResponse</code> </p> Note <p>The method updates the CDA document with new problems, allergies, and medications if they are present in the input Document object. The update behavior (overwrite or append) is determined by the <code>overwrite</code> attribute of the CdaConnector instance.</p> Source code in <code>healthchain/io/cdaconnector.py</code> <pre><code>def output(self, out_data: Document) -&gt; CdaResponse:\n    \"\"\"\n    Update the CDA document with new data and return the response.\n\n    This method takes a Document object containing updated clinical data,\n    updates the CDA document with this new information, and returns a\n    CdaResponse object with the updated CDA document.\n\n    Args:\n        out_data (Document): A Document object containing the updated\n                             clinical data (problems, allergies, medications).\n\n    Returns:\n        CdaResponse: A response object containing the updated CDA document.\n\n    Note:\n        The method updates the CDA document with new problems, allergies,\n        and medications if they are present in the input Document object.\n        The update behavior (overwrite or append) is determined by the\n        `overwrite` attribute of the CdaConnector instance.\n    \"\"\"\n    # Update the CDA document with the results\n    if out_data.ccd_data.problems:\n        log.debug(\n            f\"Updating CDA document with {len(out_data.ccd_data.problems)} problem(s).\"\n        )\n        self.cda_doc.add_to_problem_list(\n            out_data.ccd_data.problems, overwrite=self.overwrite\n        )\n    if out_data.ccd_data.allergies:\n        log.debug(\n            f\"Updating CDA document with {len(out_data.ccd_data.allergies)} allergy(ies).\"\n        )\n        self.cda_doc.add_to_allergy_list(\n            out_data.ccd_data.allergies, overwrite=self.overwrite\n        )\n    if out_data.ccd_data.medications:\n        log.debug(\n            f\"Updating CDA document with {len(out_data.ccd_data.medications)} medication(s).\"\n        )\n        self.cda_doc.add_to_medication_list(\n            out_data.ccd_data.medications, overwrite=self.overwrite\n        )\n\n    # Export the updated CDA document\n    response_document = self.cda_doc.export()\n\n    return CdaResponse(document=response_document)\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdsfhirconnector.CdsFhirConnector","title":"<code>CdsFhirConnector</code>","text":"<p>               Bases: <code>BaseConnector</code></p> <p>CdsFhirConnector class for handling FHIR (Fast Healthcare Interoperability Resources) documents for CDS Hooks.</p> <p>This connector facilitates the conversion between CDSRequest objects and Document objects, as well as the creation of CDSResponse objects from processed Documents.</p> ATTRIBUTE DESCRIPTION <code>hook_name</code> <p>The name of the CDS Hook being used.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/io/cdsfhirconnector.py</code> <pre><code>class CdsFhirConnector(BaseConnector):\n    \"\"\"\n    CdsFhirConnector class for handling FHIR (Fast Healthcare Interoperability Resources) documents\n    for CDS Hooks.\n\n    This connector facilitates the conversion between CDSRequest objects and Document objects,\n    as well as the creation of CDSResponse objects from processed Documents.\n\n    Attributes:\n        hook_name (str): The name of the CDS Hook being used.\n    \"\"\"\n\n    def __init__(self, hook_name: str):\n        self.hook_name = hook_name\n\n    def input(self, in_data: CDSRequest) -&gt; Document:\n        \"\"\"\n        Converts a CDSRequest object into a Document object containing FHIR resources.\n\n        This method takes a CDSRequest object as input, extracts the context and prefetch data,\n        and creates a CdsFhirData object. It then returns a Document object with the stringified\n        prefetch data as the main data content and the CdsFhirData object in the fhir_resources field.\n\n        Args:\n            in_data (CDSRequest): The input CDSRequest object containing context and prefetch data.\n\n        Returns:\n            Document: A Document object with the following attributes:\n                - data: A string representation of the prefetch data.\n                - fhir_resources: A CdsFhirData object containing the context and prefetch data.\n\n        Raises:\n            ValueError: If neither prefetch nor fhirServer is provided in the input data.\n            NotImplementedError: If fhirServer is provided, as this functionality is not yet implemented.\n            ValueError: If the provided prefetch data is invalid.\n\n        Note:\n            - The method currently only supports prefetch data and does not handle FHIR server interactions.\n            - Future implementations may involve more detailed processing, such as parsing\n              notes depending on the hook configuration.\n        \"\"\"\n        if in_data.prefetch is None and in_data.fhirServer is None:\n            raise ValueError(\n                \"Either prefetch or fhirServer must be provided to extract FHIR data!\"\n            )\n\n        if in_data.fhirServer is not None:\n            raise NotImplementedError(\"FHIR server is not implemented yet!\")\n\n        try:\n            cds_fhir_data = CdsFhirData.create(\n                context=in_data.context.model_dump(), prefetch=in_data.prefetch\n            )\n        except Exception as e:\n            raise ValueError(\"Invalid prefetch data provided: {e}!\") from e\n\n        return Document(\n            data=str(cds_fhir_data.model_dump_prefetch()), fhir_resources=cds_fhir_data\n        )\n\n    def output(self, out_data: Document) -&gt; CDSResponse:\n        \"\"\"\n        Generates a CDSResponse object from a processed Document object.\n\n        This method takes a Document object that has been processed and potentially\n        contains CDS cards and system actions. It creates and returns a CDSResponse\n        object based on the contents of the Document.\n\n        Args:\n            out_data (Document): A Document object potentially containing CDS cards\n                                 and system actions.\n\n        Returns:\n            CDSResponse: A response object containing CDS cards and optional system actions.\n                         If no cards are found in the Document, an empty list of cards is returned.\n\n        Note:\n            - If out_data.cds_cards is None, a warning is logged and an empty list of cards is returned.\n            - System actions (out_data.cds_actions) are included in the response if present.\n        \"\"\"\n        if out_data.cds_cards is None:\n            log.warning(\"No CDS cards found in Document, returning empty list of cards\")\n            return CDSResponse(cards=[])\n\n        return CDSResponse(cards=out_data.cds_cards, systemActions=out_data.cds_actions)\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdsfhirconnector.CdsFhirConnector.input","title":"<code>input(in_data)</code>","text":"<p>Converts a CDSRequest object into a Document object containing FHIR resources.</p> <p>This method takes a CDSRequest object as input, extracts the context and prefetch data, and creates a CdsFhirData object. It then returns a Document object with the stringified prefetch data as the main data content and the CdsFhirData object in the fhir_resources field.</p> PARAMETER DESCRIPTION <code>in_data</code> <p>The input CDSRequest object containing context and prefetch data.</p> <p> TYPE: <code>CDSRequest</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>A Document object with the following attributes: - data: A string representation of the prefetch data. - fhir_resources: A CdsFhirData object containing the context and prefetch data.</p> <p> TYPE: <code>Document</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If neither prefetch nor fhirServer is provided in the input data.</p> <code>NotImplementedError</code> <p>If fhirServer is provided, as this functionality is not yet implemented.</p> <code>ValueError</code> <p>If the provided prefetch data is invalid.</p> Note <ul> <li>The method currently only supports prefetch data and does not handle FHIR server interactions.</li> <li>Future implementations may involve more detailed processing, such as parsing   notes depending on the hook configuration.</li> </ul> Source code in <code>healthchain/io/cdsfhirconnector.py</code> <pre><code>def input(self, in_data: CDSRequest) -&gt; Document:\n    \"\"\"\n    Converts a CDSRequest object into a Document object containing FHIR resources.\n\n    This method takes a CDSRequest object as input, extracts the context and prefetch data,\n    and creates a CdsFhirData object. It then returns a Document object with the stringified\n    prefetch data as the main data content and the CdsFhirData object in the fhir_resources field.\n\n    Args:\n        in_data (CDSRequest): The input CDSRequest object containing context and prefetch data.\n\n    Returns:\n        Document: A Document object with the following attributes:\n            - data: A string representation of the prefetch data.\n            - fhir_resources: A CdsFhirData object containing the context and prefetch data.\n\n    Raises:\n        ValueError: If neither prefetch nor fhirServer is provided in the input data.\n        NotImplementedError: If fhirServer is provided, as this functionality is not yet implemented.\n        ValueError: If the provided prefetch data is invalid.\n\n    Note:\n        - The method currently only supports prefetch data and does not handle FHIR server interactions.\n        - Future implementations may involve more detailed processing, such as parsing\n          notes depending on the hook configuration.\n    \"\"\"\n    if in_data.prefetch is None and in_data.fhirServer is None:\n        raise ValueError(\n            \"Either prefetch or fhirServer must be provided to extract FHIR data!\"\n        )\n\n    if in_data.fhirServer is not None:\n        raise NotImplementedError(\"FHIR server is not implemented yet!\")\n\n    try:\n        cds_fhir_data = CdsFhirData.create(\n            context=in_data.context.model_dump(), prefetch=in_data.prefetch\n        )\n    except Exception as e:\n        raise ValueError(\"Invalid prefetch data provided: {e}!\") from e\n\n    return Document(\n        data=str(cds_fhir_data.model_dump_prefetch()), fhir_resources=cds_fhir_data\n    )\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdsfhirconnector.CdsFhirConnector.output","title":"<code>output(out_data)</code>","text":"<p>Generates a CDSResponse object from a processed Document object.</p> <p>This method takes a Document object that has been processed and potentially contains CDS cards and system actions. It creates and returns a CDSResponse object based on the contents of the Document.</p> PARAMETER DESCRIPTION <code>out_data</code> <p>A Document object potentially containing CDS cards                  and system actions.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>CDSResponse</code> <p>A response object containing CDS cards and optional system actions.          If no cards are found in the Document, an empty list of cards is returned.</p> <p> TYPE: <code>CDSResponse</code> </p> Note <ul> <li>If out_data.cds_cards is None, a warning is logged and an empty list of cards is returned.</li> <li>System actions (out_data.cds_actions) are included in the response if present.</li> </ul> Source code in <code>healthchain/io/cdsfhirconnector.py</code> <pre><code>def output(self, out_data: Document) -&gt; CDSResponse:\n    \"\"\"\n    Generates a CDSResponse object from a processed Document object.\n\n    This method takes a Document object that has been processed and potentially\n    contains CDS cards and system actions. It creates and returns a CDSResponse\n    object based on the contents of the Document.\n\n    Args:\n        out_data (Document): A Document object potentially containing CDS cards\n                             and system actions.\n\n    Returns:\n        CDSResponse: A response object containing CDS cards and optional system actions.\n                     If no cards are found in the Document, an empty list of cards is returned.\n\n    Note:\n        - If out_data.cds_cards is None, a warning is logged and an empty list of cards is returned.\n        - System actions (out_data.cds_actions) are included in the response if present.\n    \"\"\"\n    if out_data.cds_cards is None:\n        log.warning(\"No CDS cards found in Document, returning empty list of cards\")\n        return CDSResponse(cards=[])\n\n    return CDSResponse(cards=out_data.cds_cards, systemActions=out_data.cds_actions)\n</code></pre>"},{"location":"api/containers/","title":"Containers","text":""},{"location":"api/containers/#healthchain.io.containers.DataContainer","title":"<code>DataContainer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A generic container for data.</p> <p>This class represents a container for data with a specific type T.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The data stored in the container.</p> <p> TYPE: <code>T</code> </p> METHOD DESCRIPTION <code>to_dict</code> <p>Converts the container's data to a dictionary.</p> <code>to_json</code> <p>Converts the container's data to a JSON string.</p> <code>from_dict</code> <p>Dict[str, Any]) -&gt; \"DataContainer\": Creates a DataContainer instance from a dictionary.</p> <code>from_json</code> <p>str) -&gt; \"DataContainer\": Creates a DataContainer instance from a JSON string.</p> Source code in <code>healthchain/io/containers.py</code> <pre><code>@dataclass\nclass DataContainer(Generic[T]):\n    \"\"\"\n    A generic container for data.\n\n    This class represents a container for data with a specific type T.\n\n    Attributes:\n        data (T): The data stored in the container.\n\n    Methods:\n        to_dict() -&gt; Dict[str, Any]:\n            Converts the container's data to a dictionary.\n\n        to_json() -&gt; str:\n            Converts the container's data to a JSON string.\n\n        from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a dictionary.\n\n        from_json(cls, json_str: str) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a JSON string.\n    \"\"\"\n\n    data: T\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return {k: v for k, v in self.__dict__.items() if not k.startswith(\"_\")}\n\n    def to_json(self) -&gt; str:\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n        return cls(**data)\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; \"DataContainer\":\n        return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document","title":"<code>Document</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[str]</code></p> <p>A container for document data, optionally wrapping a spaCy Doc object.</p> <p>This class extends DataContainer to specifically handle textual document data. It provides functionality to work with raw text, tokenized text, spaCy Doc objects, and structured clinical data.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The raw text content of the document.</p> <p> TYPE: <code>str</code> </p> <code>preprocessed_text</code> <p>The preprocessed version of the text.</p> <p> TYPE: <code>str</code> </p> <code>tokens</code> <p>A list of individual tokens extracted from the text.</p> <p> TYPE: <code>List[str]</code> </p> <code>pos_tags</code> <p>A list of part-of-speech tags corresponding to the tokens.</p> <p> TYPE: <code>List[str]</code> </p> <code>entities</code> <p>A list of named entities identified in the text.</p> <p> TYPE: <code>List[str]</code> </p> <code>ccd_data</code> <p>An optional CcdData object containing structured clinical data.</p> <p> TYPE: <code>Optional[CcdData]</code> </p> <code>fhir_resources</code> <p>Optional FHIR resources data.</p> <p> TYPE: <code>Optional[CdsFhirData]</code> </p> <code>cds_cards</code> <p>Optional list of CDS cards.</p> <p> TYPE: <code>Optional[List[Card]]</code> </p> <code>cds_actions</code> <p>Optional list of CDS actions.</p> <p> TYPE: <code>Optional[List[Action]]</code> </p> <code>text</code> <p>The current text content, which may be updated when setting a spaCy Doc.</p> <p> TYPE: <code>str</code> </p> <code>_doc</code> <p>An internal reference to the spaCy Doc object, if set.</p> <p> TYPE: <code>Doc</code> </p> METHOD DESCRIPTION <code>__post_init__</code> <p>Initializes the text attribute and _doc reference.</p> <code>_update_attributes</code> <p>Updates tokens, pos_tags, and entities from the spaCy Doc.</p> <code>doc </code> <p>Returns the spaCy Doc object if set, or raises an error.</p> <code>set_spacy_doc</code> <p>SpacyDoc): Sets the spaCy Doc and updates related attributes.</p> <code>word_count</code> <p>Returns the number of tokens in the document.</p> <code>char_count</code> <p>Returns the number of characters in the text.</p> <code>get_entities</code> <p>Returns a list of entities with their details.</p> <code>update_ccd</code> <p>List[ProblemConcept], new_medications: List[MedicationConcept], new_allergies: List[AllergyConcept], overwrite: bool): Updates the existing CcdData object.</p> <code>__iter__</code> <p>Allows iteration over the document's tokens.</p> <code>__len__</code> <p>Returns the word count of the document.</p> RAISES DESCRIPTION <code>ValueError</code> <p>When attempting to access the spaCy Doc before it's set.</p> Note <p>The spaCy Doc object needs to be set using a preprocessor before accessing certain attributes and methods that depend on it.</p> Source code in <code>healthchain/io/containers.py</code> <pre><code>@dataclass\nclass Document(DataContainer[str]):\n    \"\"\"\n    A container for document data, optionally wrapping a spaCy Doc object.\n\n    This class extends DataContainer to specifically handle textual document data.\n    It provides functionality to work with raw text, tokenized text, spaCy Doc objects,\n    and structured clinical data.\n\n    Attributes:\n        data (str): The raw text content of the document.\n        preprocessed_text (str): The preprocessed version of the text.\n        tokens (List[str]): A list of individual tokens extracted from the text.\n        pos_tags (List[str]): A list of part-of-speech tags corresponding to the tokens.\n        entities (List[str]): A list of named entities identified in the text.\n        ccd_data (Optional[CcdData]): An optional CcdData object containing structured clinical data.\n        fhir_resources (Optional[CdsFhirData]): Optional FHIR resources data.\n        cds_cards (Optional[List[Card]]): Optional list of CDS cards.\n        cds_actions (Optional[List[Action]]): Optional list of CDS actions.\n        text (str): The current text content, which may be updated when setting a spaCy Doc.\n        _doc (SpacyDoc): An internal reference to the spaCy Doc object, if set.\n\n    Methods:\n        __post_init__(): Initializes the text attribute and _doc reference.\n        _update_attributes(): Updates tokens, pos_tags, and entities from the spaCy Doc.\n        doc (property): Returns the spaCy Doc object if set, or raises an error.\n        set_spacy_doc(doc: SpacyDoc): Sets the spaCy Doc and updates related attributes.\n        word_count() -&gt; int: Returns the number of tokens in the document.\n        char_count() -&gt; int: Returns the number of characters in the text.\n        get_entities() -&gt; List[Dict[str, Any]]: Returns a list of entities with their details.\n        update_ccd(new_problems: List[ProblemConcept], new_medications: List[MedicationConcept], new_allergies: List[AllergyConcept], overwrite: bool): Updates the existing CcdData object.\n        __iter__() -&gt; Iterator[str]: Allows iteration over the document's tokens.\n        __len__() -&gt; int: Returns the word count of the document.\n\n    Raises:\n        ValueError: When attempting to access the spaCy Doc before it's set.\n\n    Note:\n        The spaCy Doc object needs to be set using a preprocessor before accessing\n        certain attributes and methods that depend on it.\n    \"\"\"\n\n    preprocessed_text: str = field(default=\"\")\n    tokens: List[str] = field(default_factory=list)\n    pos_tags: List[str] = field(default_factory=list)\n    entities: List[str] = field(default_factory=list)\n    ccd_data: Optional[CcdData] = field(default=None)\n    fhir_resources: Optional[CdsFhirData] = field(default=None)\n    cds_cards: Optional[List[Card]] = field(default=None)\n    cds_actions: Optional[List[Action]] = field(default=None)\n\n    def __post_init__(self):\n        self.text = self.data\n        self._doc = None\n\n    def _update_attributes(self):\n        self.tokens = [token.text for token in self._doc]\n        self.pos_tags = [token.pos_ for token in self._doc]\n        self.entities = [ent.text for ent in self._doc.ents]\n\n    @property\n    def doc(self) -&gt; SpacyDoc:\n        if self._doc is None:\n            raise ValueError(\n                \"spaCy Doc is not set. Use a preprocessor to set the spaCy Doc.\"\n            )\n        return self._doc\n\n    def set_spacy_doc(self, doc: SpacyDoc) -&gt; None:\n        self._doc = doc\n        self.text = self._doc.text\n        self._update_attributes()\n\n    def word_count(self) -&gt; int:\n        return len(self.tokens)\n\n    def char_count(self) -&gt; int:\n        return len(self.text)\n\n    def get_entities(self) -&gt; List[Dict[str, Any]]:\n        if self._doc is None:\n            return self.entities\n        return [\n            {\n                \"text\": ent.text,\n                \"label\": ent.label_,\n                \"start\": ent.start_char,\n                \"end\": ent.end_char,\n            }\n            for ent in self._doc.ents\n        ]\n\n    def update_ccd(\n        self,\n        new_problems: List[ProblemConcept],\n        new_medications: List[MedicationConcept],\n        new_allergies: List[AllergyConcept],\n        overwrite: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Updates the existing CcdData object with new data.\n\n        Args:\n            new_problems (List[ProblemConcept]): List of new problem concepts to add or update.\n            new_medications (List[MedicationConcept]): List of new medication concepts to add or update.\n            new_allergies (List[AllergyConcept]): List of new allergy concepts to add or update.\n            overwrite (bool, optional): If True, replaces existing data; if False, appends new data. Defaults to False.\n\n        Raises:\n            ValueError: If there is no existing CcdData object to update.\n        \"\"\"\n        if self.ccd_data is None:\n            self.ccd_data = CcdData()\n\n        if overwrite:\n            self.ccd_data.problems = new_problems\n            self.ccd_data.medications = new_medications\n            self.ccd_data.allergies = new_allergies\n        else:\n            self.ccd_data.problems.extend(new_problems)\n            self.ccd_data.medications.extend(new_medications)\n            self.ccd_data.allergies.extend(new_allergies)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self.tokens)\n\n    def __len__(self) -&gt; int:\n        return self.word_count()\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.update_ccd","title":"<code>update_ccd(new_problems, new_medications, new_allergies, overwrite=False)</code>","text":"<p>Updates the existing CcdData object with new data.</p> PARAMETER DESCRIPTION <code>new_problems</code> <p>List of new problem concepts to add or update.</p> <p> TYPE: <code>List[ProblemConcept]</code> </p> <code>new_medications</code> <p>List of new medication concepts to add or update.</p> <p> TYPE: <code>List[MedicationConcept]</code> </p> <code>new_allergies</code> <p>List of new allergy concepts to add or update.</p> <p> TYPE: <code>List[AllergyConcept]</code> </p> <code>overwrite</code> <p>If True, replaces existing data; if False, appends new data. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If there is no existing CcdData object to update.</p> Source code in <code>healthchain/io/containers.py</code> <pre><code>def update_ccd(\n    self,\n    new_problems: List[ProblemConcept],\n    new_medications: List[MedicationConcept],\n    new_allergies: List[AllergyConcept],\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Updates the existing CcdData object with new data.\n\n    Args:\n        new_problems (List[ProblemConcept]): List of new problem concepts to add or update.\n        new_medications (List[MedicationConcept]): List of new medication concepts to add or update.\n        new_allergies (List[AllergyConcept]): List of new allergy concepts to add or update.\n        overwrite (bool, optional): If True, replaces existing data; if False, appends new data. Defaults to False.\n\n    Raises:\n        ValueError: If there is no existing CcdData object to update.\n    \"\"\"\n    if self.ccd_data is None:\n        self.ccd_data = CcdData()\n\n    if overwrite:\n        self.ccd_data.problems = new_problems\n        self.ccd_data.medications = new_medications\n        self.ccd_data.allergies = new_allergies\n    else:\n        self.ccd_data.problems.extend(new_problems)\n        self.ccd_data.medications.extend(new_medications)\n        self.ccd_data.allergies.extend(new_allergies)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Tabular","title":"<code>Tabular</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[DataFrame]</code></p> <p>A container for tabular data, wrapping a pandas DataFrame.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The pandas DataFrame containing the tabular data.</p> <p> TYPE: <code>DataFrame</code> </p> METHOD DESCRIPTION <code>__post_init__</code> <p>Validates that the data is a pandas DataFrame.</p> <code>columns</code> <p>Property that returns a list of column names.</p> <code>index</code> <p>Property that returns the DataFrame's index.</p> <code>dtypes</code> <p>Property that returns a dictionary of column names and their data types.</p> <code>column_count</code> <p>Returns the number of columns in the DataFrame.</p> <code>row_count</code> <p>Returns the number of rows in the DataFrame.</p> <code>get_dtype</code> <p>str): Returns the data type of a specific column.</p> <code>__iter__</code> <p>Returns an iterator over the column names.</p> <code>__len__</code> <p>Returns the number of rows in the DataFrame.</p> <code>describe</code> <p>Returns a string description of the tabular data.</p> <code>remove_column</code> <p>str): Removes a column from the DataFrame.</p> <code>from_csv</code> <p>str, **kwargs): Class method to create a Tabular object from a CSV file.</p> <code>from_dict</code> <p>Dict[str, Any]): Class method to create a Tabular object from a dictionary.</p> <code>to_csv</code> <p>str, **kwargs): Saves the DataFrame to a CSV file.</p> Source code in <code>healthchain/io/containers.py</code> <pre><code>@dataclass\nclass Tabular(DataContainer[pd.DataFrame]):\n    \"\"\"\n    A container for tabular data, wrapping a pandas DataFrame.\n\n    Attributes:\n        data (pd.DataFrame): The pandas DataFrame containing the tabular data.\n\n    Methods:\n        __post_init__(): Validates that the data is a pandas DataFrame.\n        columns: Property that returns a list of column names.\n        index: Property that returns the DataFrame's index.\n        dtypes: Property that returns a dictionary of column names and their data types.\n        column_count(): Returns the number of columns in the DataFrame.\n        row_count(): Returns the number of rows in the DataFrame.\n        get_dtype(column: str): Returns the data type of a specific column.\n        __iter__(): Returns an iterator over the column names.\n        __len__(): Returns the number of rows in the DataFrame.\n        describe(): Returns a string description of the tabular data.\n        remove_column(name: str): Removes a column from the DataFrame.\n        from_csv(path: str, **kwargs): Class method to create a Tabular object from a CSV file.\n        from_dict(data: Dict[str, Any]): Class method to create a Tabular object from a dictionary.\n        to_csv(path: str, **kwargs): Saves the DataFrame to a CSV file.\n    \"\"\"\n\n    def __post_init__(self):\n        if not isinstance(self.data, pd.DataFrame):\n            raise TypeError(\"data must be a pandas DataFrame\")\n\n    @property\n    def columns(self) -&gt; List[str]:\n        return list(self.data.columns)\n\n    @property\n    def index(self) -&gt; pd.Index:\n        return self.data.index\n\n    @property\n    def dtypes(self) -&gt; Dict[str, str]:\n        return {col: str(dtype) for col, dtype in self.data.dtypes.items()}\n\n    def column_count(self) -&gt; int:\n        return len(self.columns)\n\n    def row_count(self) -&gt; int:\n        return len(self.data)\n\n    def get_dtype(self, column: str) -&gt; str:\n        return str(self.data[column].dtype)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self.columns)\n\n    def __len__(self) -&gt; int:\n        return self.row_count()\n\n    def describe(self) -&gt; str:\n        return f\"Tabular data with {self.column_count()} columns and {self.row_count()} rows\"\n\n    def remove_column(self, name: str) -&gt; None:\n        self.data.drop(columns=[name], inplace=True)\n\n    @classmethod\n    def from_csv(cls, path: str, **kwargs) -&gt; \"Tabular\":\n        return cls(pd.read_csv(path, **kwargs))\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Tabular\":\n        df = pd.DataFrame(**data[\"data\"])\n        return cls(df)\n\n    def to_csv(self, path: str, **kwargs) -&gt; None:\n        self.data.to_csv(path, **kwargs)\n</code></pre>"},{"location":"api/data_generators/","title":"Data Generators","text":""},{"location":"api/data_generators/#healthchain.data_generators.cdsdatagenerator.CdsDataGenerator","title":"<code>CdsDataGenerator</code>","text":"<p>A class to generate CDS (Clinical Decision Support) data based on specified workflows and constraints.</p> ATTRIBUTE DESCRIPTION <code>registry</code> <p>A registry of data generators.</p> <p> TYPE: <code>dict</code> </p> <code>mappings</code> <p>A mapping of workflows to their respective data generators.</p> <p> TYPE: <code>dict</code> </p> <code>data</code> <p>The generated CDS FHIR data.</p> <p> TYPE: <code>CdsFhirData</code> </p> Source code in <code>healthchain/data_generators/cdsdatagenerator.py</code> <pre><code>class CdsDataGenerator:\n    \"\"\"\n    A class to generate CDS (Clinical Decision Support) data based on specified workflows and constraints.\n\n    Attributes:\n        registry (dict): A registry of data generators.\n        mappings (dict): A mapping of workflows to their respective data generators.\n        data (CdsFhirData): The generated CDS FHIR data.\n    \"\"\"\n\n    def __init__(self):\n        self.registry = generator_registry\n        self.mappings = workflow_mappings\n        self.data: CdsFhirData = None\n\n    def fetch_generator(self, generator_name: str) -&gt; Callable:\n        \"\"\"\n        Fetches a data generator function by its name from the registry.\n\n        Parameters:\n            generator_name (str): The name of the data generator to fetch.\n\n        Returns:\n            Callable: The data generator function.\n        \"\"\"\n        return self.registry.get(generator_name)\n\n    def set_workflow(self, workflow: str) -&gt; None:\n        \"\"\"\n        Sets the current workflow to be used for data generation.\n\n        Parameters:\n            workflow (str): The name of the workflow to set.\n        \"\"\"\n        self.workflow = workflow\n\n    def generate(\n        self,\n        constraints: Optional[list] = None,\n        free_text_path: Optional[str] = None,\n        column_name: Optional[str] = None,\n        random_seed: Optional[int] = None,\n    ) -&gt; BaseModel:\n        \"\"\"\n        Generates CDS data based on the current workflow, constraints, and optional free text data.\n\n        Parameters:\n            constraints (Optional[list]): A list of constraints to apply to the data generation.\n            free_text_path (Optional[str]): The path to a CSV file containing free text data.\n            column_name (Optional[str]): The column name in the CSV file to use for free text data.\n            random_seed (Optional[int]): The random seed to use for reproducible data generation.\n\n        Returns:\n            BaseModel: The generated CDS FHIR data.\n        \"\"\"\n        results = []\n\n        if self.workflow not in self.mappings.keys():\n            raise ValueError(f\"Workflow {self.workflow} not found in mappings\")\n\n        for resource in self.mappings[self.workflow]:\n            generator_name = resource[\"generator\"]\n            generator = self.fetch_generator(generator_name)\n            result = generator.generate(\n                constraints=constraints, random_seed=random_seed\n            )\n\n            results.append(BundleEntry(resource=result))\n\n        parsed_free_text = (\n            self.free_text_parser(free_text_path, column_name)\n            if free_text_path\n            else None\n        )\n        if parsed_free_text:\n            results.append(BundleEntry(resource=random.choice(parsed_free_text)))\n\n        output = CdsFhirData(prefetch=Bundle(entry=results))\n        self.data = output\n        return output\n\n    def free_text_parser(self, path_to_csv: str, column_name: str) -&gt; Dict:\n        \"\"\"\n        Parses free text data from a CSV file and converts it into a list of DocumentReference models.\n\n        Parameters:\n            path_to_csv (str): The path to the CSV file containing free text data.\n            column_name (str): The column name in the CSV file to use for free text data.\n\n        Returns:\n            dict: A dictionary of parsed free text data converted into DocumentReference models.\n        \"\"\"\n        column_data = []\n\n        # Check that path_to_csv is a valid path with pathlib\n        path = Path(path_to_csv)\n        if not path.is_file():\n            raise FileNotFoundError(\n                f\"The file {path_to_csv} does not exist or is not a file.\"\n            )\n\n        try:\n            with path.open(mode=\"r\", newline=\"\") as file:\n                reader = csv.DictReader(file)\n                if column_name is not None:\n                    for row in reader:\n                        column_data.append(row[column_name])\n                else:\n                    raise ValueError(\n                        \"Column name must be provided when header is True.\"\n                    )\n        except Exception as ex:\n            logger.error(f\"An error occurred: {ex}\")\n\n        document_list = []\n\n        for x in column_data:\n            # First parse x in to documentreferencemodel format\n            text = Narrative(\n                status=\"generated\",\n                div=f'&lt;div xmlns=\"http://www.w3.org/1999/xhtml\"&gt;{x}&lt;/div&gt;',\n            )\n            doc = DocumentReference(text=text)\n            document_list.append(doc)\n\n        return document_list\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.cdsdatagenerator.CdsDataGenerator.fetch_generator","title":"<code>fetch_generator(generator_name)</code>","text":"<p>Fetches a data generator function by its name from the registry.</p> PARAMETER DESCRIPTION <code>generator_name</code> <p>The name of the data generator to fetch.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>The data generator function.</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>healthchain/data_generators/cdsdatagenerator.py</code> <pre><code>def fetch_generator(self, generator_name: str) -&gt; Callable:\n    \"\"\"\n    Fetches a data generator function by its name from the registry.\n\n    Parameters:\n        generator_name (str): The name of the data generator to fetch.\n\n    Returns:\n        Callable: The data generator function.\n    \"\"\"\n    return self.registry.get(generator_name)\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.cdsdatagenerator.CdsDataGenerator.free_text_parser","title":"<code>free_text_parser(path_to_csv, column_name)</code>","text":"<p>Parses free text data from a CSV file and converts it into a list of DocumentReference models.</p> PARAMETER DESCRIPTION <code>path_to_csv</code> <p>The path to the CSV file containing free text data.</p> <p> TYPE: <code>str</code> </p> <code>column_name</code> <p>The column name in the CSV file to use for free text data.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary of parsed free text data converted into DocumentReference models.</p> <p> TYPE: <code>Dict</code> </p> Source code in <code>healthchain/data_generators/cdsdatagenerator.py</code> <pre><code>def free_text_parser(self, path_to_csv: str, column_name: str) -&gt; Dict:\n    \"\"\"\n    Parses free text data from a CSV file and converts it into a list of DocumentReference models.\n\n    Parameters:\n        path_to_csv (str): The path to the CSV file containing free text data.\n        column_name (str): The column name in the CSV file to use for free text data.\n\n    Returns:\n        dict: A dictionary of parsed free text data converted into DocumentReference models.\n    \"\"\"\n    column_data = []\n\n    # Check that path_to_csv is a valid path with pathlib\n    path = Path(path_to_csv)\n    if not path.is_file():\n        raise FileNotFoundError(\n            f\"The file {path_to_csv} does not exist or is not a file.\"\n        )\n\n    try:\n        with path.open(mode=\"r\", newline=\"\") as file:\n            reader = csv.DictReader(file)\n            if column_name is not None:\n                for row in reader:\n                    column_data.append(row[column_name])\n            else:\n                raise ValueError(\n                    \"Column name must be provided when header is True.\"\n                )\n    except Exception as ex:\n        logger.error(f\"An error occurred: {ex}\")\n\n    document_list = []\n\n    for x in column_data:\n        # First parse x in to documentreferencemodel format\n        text = Narrative(\n            status=\"generated\",\n            div=f'&lt;div xmlns=\"http://www.w3.org/1999/xhtml\"&gt;{x}&lt;/div&gt;',\n        )\n        doc = DocumentReference(text=text)\n        document_list.append(doc)\n\n    return document_list\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.cdsdatagenerator.CdsDataGenerator.generate","title":"<code>generate(constraints=None, free_text_path=None, column_name=None, random_seed=None)</code>","text":"<p>Generates CDS data based on the current workflow, constraints, and optional free text data.</p> PARAMETER DESCRIPTION <code>constraints</code> <p>A list of constraints to apply to the data generation.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> <code>free_text_path</code> <p>The path to a CSV file containing free text data.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>column_name</code> <p>The column name in the CSV file to use for free text data.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>random_seed</code> <p>The random seed to use for reproducible data generation.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>BaseModel</code> <p>The generated CDS FHIR data.</p> <p> TYPE: <code>BaseModel</code> </p> Source code in <code>healthchain/data_generators/cdsdatagenerator.py</code> <pre><code>def generate(\n    self,\n    constraints: Optional[list] = None,\n    free_text_path: Optional[str] = None,\n    column_name: Optional[str] = None,\n    random_seed: Optional[int] = None,\n) -&gt; BaseModel:\n    \"\"\"\n    Generates CDS data based on the current workflow, constraints, and optional free text data.\n\n    Parameters:\n        constraints (Optional[list]): A list of constraints to apply to the data generation.\n        free_text_path (Optional[str]): The path to a CSV file containing free text data.\n        column_name (Optional[str]): The column name in the CSV file to use for free text data.\n        random_seed (Optional[int]): The random seed to use for reproducible data generation.\n\n    Returns:\n        BaseModel: The generated CDS FHIR data.\n    \"\"\"\n    results = []\n\n    if self.workflow not in self.mappings.keys():\n        raise ValueError(f\"Workflow {self.workflow} not found in mappings\")\n\n    for resource in self.mappings[self.workflow]:\n        generator_name = resource[\"generator\"]\n        generator = self.fetch_generator(generator_name)\n        result = generator.generate(\n            constraints=constraints, random_seed=random_seed\n        )\n\n        results.append(BundleEntry(resource=result))\n\n    parsed_free_text = (\n        self.free_text_parser(free_text_path, column_name)\n        if free_text_path\n        else None\n    )\n    if parsed_free_text:\n        results.append(BundleEntry(resource=random.choice(parsed_free_text)))\n\n    output = CdsFhirData(prefetch=Bundle(entry=results))\n    self.data = output\n    return output\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.cdsdatagenerator.CdsDataGenerator.set_workflow","title":"<code>set_workflow(workflow)</code>","text":"<p>Sets the current workflow to be used for data generation.</p> PARAMETER DESCRIPTION <code>workflow</code> <p>The name of the workflow to set.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/data_generators/cdsdatagenerator.py</code> <pre><code>def set_workflow(self, workflow: str) -&gt; None:\n    \"\"\"\n    Sets the current workflow to be used for data generation.\n\n    Parameters:\n        workflow (str): The name of the workflow to set.\n    \"\"\"\n    self.workflow = workflow\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.encountergenerators.ClassGenerator","title":"<code>ClassGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>A generator class for creating FHIR Class resources.</p> METHOD DESCRIPTION <code>generate</code> <p>Generates a FHIR Class resource.</p> Source code in <code>healthchain/data_generators/encountergenerators.py</code> <pre><code>@register_generator\nclass ClassGenerator(BaseGenerator):\n    \"\"\"\n    A generator class for creating FHIR Class resources.\n\n    Methods:\n        generate() -&gt; CodeableConcept:\n            Generates a FHIR Class resource.\n    \"\"\"\n\n    @staticmethod\n    def generate() -&gt; CodeableConcept:\n        patient_class_mapping = {\"IMP\": \"inpatient\", \"AMB\": \"ambulatory\"}\n        patient_class = faker.random_element(elements=(\"IMP\", \"AMB\"))\n        return CodeableConcept(\n            coding=[\n                Coding(\n                    system=\"http://terminology.hl7.org/CodeSystem/v3-ActCode\",\n                    code=patient_class,\n                    display=patient_class_mapping.get(patient_class),\n                )\n            ]\n        )\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.encountergenerators.EncounterGenerator","title":"<code>EncounterGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>A generator class for creating FHIR Encounter resources.</p> METHOD DESCRIPTION <code>generate</code> <p>Optional[list] = None, random_seed: Optional[int] = None) -&gt; Encounter: Generates a FHIR Encounter resource with optional constraints and random_seed.</p> Source code in <code>healthchain/data_generators/encountergenerators.py</code> <pre><code>@register_generator\nclass EncounterGenerator(BaseGenerator):\n    \"\"\"\n    A generator class for creating FHIR Encounter resources.\n\n    Methods:\n        generate(constraints: Optional[list] = None, random_seed: Optional[int] = None) -&gt; Encounter:\n            Generates a FHIR Encounter resource with optional constraints and random_seed.\n    \"\"\"\n\n    @staticmethod\n    def generate(\n        constraints: Optional[list] = None,\n        random_seed: Optional[int] = None,\n    ) -&gt; Encounter:\n        Faker.seed(random_seed)\n        patient_reference = \"Patient/123\"\n        return Encounter(\n            resourceType=\"Encounter\",\n            id=generator_registry.get(\"IdGenerator\").generate(),\n            status=faker.random_element(\n                elements=(\n                    \"planned\",\n                    \"in-progress\",\n                    \"on-hold\",\n                    \"discharged\",\n                    \"cancelled\",\n                )\n            ),\n            class_field=[generator_registry.get(\"ClassGenerator\").generate()],\n            priority=generator_registry.get(\"EncounterPriorityGenerator\").generate(),\n            type_field=[generator_registry.get(\"EncounterTypeGenerator\").generate()],\n            subject={\"reference\": patient_reference, \"display\": patient_reference},\n            actualPeriod=generator_registry.get(\"PeriodGenerator\").generate(),\n            location=[generator_registry.get(\"EncounterLocationGenerator\").generate()],\n            participant=[],\n            reason=[],\n        )\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.encountergenerators.EncounterLocationGenerator","title":"<code>EncounterLocationGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>A generator class for creating FHIR EncounterLocation resources.</p> METHOD DESCRIPTION <code>generate</code> <p>Generates a FHIR EncounterLocation resource.</p> Source code in <code>healthchain/data_generators/encountergenerators.py</code> <pre><code>@register_generator\nclass EncounterLocationGenerator(BaseGenerator):\n    \"\"\"\n    A generator class for creating FHIR EncounterLocation resources.\n\n    Methods:\n        generate() -&gt; EncounterLocation:\n            Generates a FHIR EncounterLocation resource.\n    \"\"\"\n\n    @staticmethod\n    def generate() -&gt; EncounterLocation:\n        return EncounterLocation(\n            location=Reference(reference=\"Location/123\"),\n            status=faker.random_element(elements=(\"active\", \"completed\")),\n            period=generator_registry.get(\"PeriodGenerator\").generate(),\n        )\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.encountergenerators.EncounterPriorityGenerator","title":"<code>EncounterPriorityGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>A generator class for creating FHIR EncounterPriority resources.</p> METHOD DESCRIPTION <code>generate</code> <p>Generates a FHIR EncounterPriority resource.</p> Source code in <code>healthchain/data_generators/encountergenerators.py</code> <pre><code>@register_generator\nclass EncounterPriorityGenerator(BaseGenerator):\n    \"\"\"\n    A generator class for creating FHIR EncounterPriority resources.\n\n    Methods:\n        generate() -&gt; CodeableConcept:\n            Generates a FHIR EncounterPriority resource.\n    \"\"\"\n\n    @staticmethod\n    def generate() -&gt; CodeableConcept:\n        encounter_priority_mapping = {\"17621005\": \"normal\", \"24484000\": \"critical\"}\n        encounter_priority = faker.random_element(elements=(\"17621005\", \"24484000\"))\n        return CodeableConcept(\n            coding=[\n                Coding(\n                    system=\"http://snomed.info/sct\",\n                    code=encounter_priority,\n                    display=encounter_priority_mapping.get(encounter_priority),\n                )\n            ]\n        )\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.encountergenerators.EncounterTypeGenerator","title":"<code>EncounterTypeGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>A generator class for creating FHIR EncounterType resources.</p> METHOD DESCRIPTION <code>generate</code> <p>Generates a FHIR EncounterType resource.</p> Source code in <code>healthchain/data_generators/encountergenerators.py</code> <pre><code>@register_generator\nclass EncounterTypeGenerator(BaseGenerator):\n    \"\"\"\n    A generator class for creating FHIR EncounterType resources.\n\n    Methods:\n        generate() -&gt; CodeableConcept:\n            Generates a FHIR EncounterType resource.\n    \"\"\"\n\n    @staticmethod\n    def generate() -&gt; CodeableConcept:\n        encounter_type_mapping = {\"11429006\": \"consultation\", \"50849002\": \"emergency\"}\n        encounter_type = faker.random_element(elements=(\"11429006\", \"50849002\"))\n        return CodeableConcept(\n            coding=[\n                Coding(\n                    system=\"http://snomed.info/sct\",\n                    code=encounter_type,\n                    display=encounter_type_mapping.get(encounter_type),\n                )\n            ]\n        )\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.encountergenerators.PeriodGenerator","title":"<code>PeriodGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>A generator class for creating FHIR Period resources.</p> METHOD DESCRIPTION <code>generate</code> <p>Generates a FHIR Period resource with random start and end times.</p> Source code in <code>healthchain/data_generators/encountergenerators.py</code> <pre><code>@register_generator\nclass PeriodGenerator(BaseGenerator):\n    \"\"\"\n    A generator class for creating FHIR Period resources.\n\n    Methods:\n        generate() -&gt; Period:\n            Generates a FHIR Period resource with random start and end times.\n    \"\"\"\n\n    @staticmethod\n    def generate():\n        start = faker.date_time()\n        end = faker.date_time_between(start_date=start).isoformat()\n        start = start.isoformat()\n        return Period(\n            start=dateTimeModel(start),\n            end=dateTimeModel(end),\n        )\n</code></pre>"},{"location":"api/data_models/","title":"Data Models","text":""},{"location":"api/data_models/#healthchain.models.data.ccddata.CcdData","title":"<code>CcdData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for CCD (Continuity of Care Document) that can be converted to CDA. Data is stored as FHIR.</p> Source code in <code>healthchain/models/data/ccddata.py</code> <pre><code>class CcdData(BaseModel):\n    \"\"\"\n    Data model for CCD (Continuity of Care Document) that can be converted to CDA.\n    Data is stored as FHIR.\n    \"\"\"\n\n    problems: Optional[List[ProblemConcept]] = None\n    allergies: Optional[List[AllergyConcept]] = None\n    medications: Optional[List[MedicationConcept]] = None\n    note: Optional[Union[Dict, str]] = None\n    cda_xml: Optional[str] = None\n</code></pre>"},{"location":"api/data_models/#healthchain.models.data.cdsfhirdata.CdsFhirData","title":"<code>CdsFhirData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for CDS FHIR data, matching the expected fields in CDSRequests.</p> ATTRIBUTE DESCRIPTION <code>context</code> <p>A dictionary containing contextual information for the CDS request.</p> <p> TYPE: <code>Dict</code> </p> <code>prefetch</code> <p>A Bundle object containing prefetched FHIR resources.</p> <p> TYPE: <code>Bundle</code> </p> METHOD DESCRIPTION <code>create</code> <p>Dict, prefetch: Dict): Class method to create a CdsFhirData instance.</p> <code>model_dump</code> <p>Returns a dictionary representation of the model.</p> <code>model_dump_json</code> <p>Returns a JSON string representation of the model.</p> <code>model_dump_prefetch</code> <p>Returns a dictionary representation of the prefetch Bundle.</p> Source code in <code>healthchain/models/data/cdsfhirdata.py</code> <pre><code>class CdsFhirData(BaseModel):\n    \"\"\"\n    Data model for CDS FHIR data, matching the expected fields in CDSRequests.\n\n    Attributes:\n        context (Dict): A dictionary containing contextual information for the CDS request.\n        prefetch (Bundle): A Bundle object containing prefetched FHIR resources.\n\n    Methods:\n        create(cls, context: Dict, prefetch: Dict): Class method to create a CdsFhirData instance.\n        model_dump(*args, **kwargs): Returns a dictionary representation of the model.\n        model_dump_json(*args, **kwargs): Returns a JSON string representation of the model.\n        model_dump_prefetch(*args, **kwargs): Returns a dictionary representation of the prefetch Bundle.\n    \"\"\"\n\n    context: Dict = Field(default={})\n    prefetch: Bundle\n\n    @classmethod\n    def create(cls, context: Dict, prefetch: Dict):\n        # deep copy to avoid modifying the original prefetch data\n        prefetch_copy = copy.deepcopy(prefetch)\n        bundle = Bundle(**prefetch_copy)\n        return cls(context=context, prefetch=bundle)\n\n    def model_dump(self, *args, **kwargs):\n        kwargs.setdefault(\"exclude_unset\", True)\n        kwargs.setdefault(\"exclude_none\", True)\n        kwargs.setdefault(\"by_alias\", True)\n\n        return super().model_dump(*args, **kwargs)\n\n    def model_dump_json(self, *args, **kwargs):\n        kwargs.setdefault(\"exclude_unset\", True)\n        kwargs.setdefault(\"exclude_none\", True)\n        kwargs.setdefault(\"by_alias\", True)\n\n        return super().model_dump_json(*args, **kwargs)\n\n    def model_dump_prefetch(self, *args, **kwargs):\n        kwargs.setdefault(\"exclude_unset\", True)\n        kwargs.setdefault(\"exclude_none\", True)\n        kwargs.setdefault(\"by_alias\", True)\n\n        return self.prefetch.model_dump(*args, **kwargs)\n</code></pre>"},{"location":"api/data_models/#healthchain.models.data.concept.AllergyConcept","title":"<code>AllergyConcept</code>","text":"<p>               Bases: <code>Concept</code></p> <p>Contains allergy specific fields</p> <p>Defaults allergy type to propensity to adverse reactions in SNOMED CT</p> Source code in <code>healthchain/models/data/concept.py</code> <pre><code>class AllergyConcept(Concept):\n    \"\"\"\n    Contains allergy specific fields\n\n    Defaults allergy type to propensity to adverse reactions in SNOMED CT\n    \"\"\"\n\n    allergy_type: Optional[Concept] = Field(\n        default=Concept(\n            code=\"420134006\",\n            code_system=\"2.16.840.1.113883.6.96\",\n            code_system_name=\"SNOMED CT\",\n            display_name=\"Propensity to adverse reactions\",\n        )\n    )\n    severity: Optional[Concept] = None\n    reaction: Optional[Concept] = None\n</code></pre>"},{"location":"api/data_models/#healthchain.models.data.concept.Concept","title":"<code>Concept</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A more lenient, system agnostic representation of a concept e.g. problems, medications, allergies that can be converted to CDA or FHIR</p> Source code in <code>healthchain/models/data/concept.py</code> <pre><code>class Concept(BaseModel):\n    \"\"\"\n    A more lenient, system agnostic representation of a concept e.g. problems, medications, allergies\n    that can be converted to CDA or FHIR\n    \"\"\"\n\n    _standard: Optional[Standard] = None\n    code: Optional[str] = None\n    code_system: Optional[str] = None\n    code_system_name: Optional[str] = None\n    display_name: Optional[str] = None\n</code></pre>"},{"location":"api/data_models/#healthchain.models.data.concept.DataType","title":"<code>DataType</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all data types</p> Source code in <code>healthchain/models/data/concept.py</code> <pre><code>class DataType(BaseModel):\n    \"\"\"\n    Base class for all data types\n    \"\"\"\n\n    _source: Optional[Dict] = None\n</code></pre>"},{"location":"api/data_models/#healthchain.models.data.concept.MedicationConcept","title":"<code>MedicationConcept</code>","text":"<p>               Bases: <code>Concept</code></p> <p>Contains medication specific fields</p> Source code in <code>healthchain/models/data/concept.py</code> <pre><code>class MedicationConcept(Concept):\n    \"\"\"\n    Contains medication specific fields\n    \"\"\"\n\n    dosage: Optional[Quantity] = None\n    route: Optional[Concept] = None\n    frequency: Optional[TimeInterval] = None\n    duration: Optional[Range] = None\n    precondition: Optional[Dict] = None\n</code></pre>"},{"location":"api/data_models/#healthchain.models.data.concept.ProblemConcept","title":"<code>ProblemConcept</code>","text":"<p>               Bases: <code>Concept</code></p> <p>Contains problem/condition specific fields</p> Source code in <code>healthchain/models/data/concept.py</code> <pre><code>class ProblemConcept(Concept):\n    \"\"\"\n    Contains problem/condition specific fields\n    \"\"\"\n\n    onset_date: Optional[str] = None\n    abatement_date: Optional[str] = None\n    status: Optional[str] = None\n    recorded_date: Optional[str] = None\n</code></pre>"},{"location":"api/pipeline/","title":"Pipeline","text":""},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline","title":"<code>BasePipeline</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract BasePipeline class for creating and managing a data processing pipeline. The BasePipeline class allows users to create a data processing pipeline by adding components and defining their dependencies and execution order. It provides methods for adding, removing, and replacing components, as well as building and executing the pipeline. This is an abstract base class and should be subclassed to create specific pipeline implementations. Attributes:     components (List[PipelineNode]): A list of PipelineNode objects representing the components in the pipeline.     stages (Dict[str, List[Callable]]): A dictionary mapping stage names to lists of component functions.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>class BasePipeline(Generic[T], ABC):\n    \"\"\"\n    Abstract BasePipeline class for creating and managing a data processing pipeline.\n    The BasePipeline class allows users to create a data processing pipeline by adding components and defining their dependencies and execution order. It provides methods for adding, removing, and replacing components, as well as building and executing the pipeline.\n    This is an abstract base class and should be subclassed to create specific pipeline implementations.\n    Attributes:\n        components (List[PipelineNode]): A list of PipelineNode objects representing the components in the pipeline.\n        stages (Dict[str, List[Callable]]): A dictionary mapping stage names to lists of component functions.\n    \"\"\"\n\n    def __init__(self):\n        self._components: List[PipelineNode[T]] = []\n        self._stages: Dict[str, List[Callable]] = {}\n        self._built_pipeline: Optional[Callable] = None\n        self._input_connector: Optional[BaseConnector[T]] = None\n        self._output_connector: Optional[BaseConnector[T]] = None\n\n    def __repr__(self) -&gt; str:\n        components_repr = \", \".join(\n            [f'\"{component.name}\"' for component in self._components]\n        )\n        return f\"[{components_repr}]\"\n\n    @classmethod\n    def load(cls, model_path: str) -&gt; \"BasePipeline\":\n        \"\"\"\n        Load and configure a pipeline from a given model path.\n\n        This class method creates a new instance of the pipeline, configures it\n        using the provided model path, and returns the configured pipeline.\n\n        Args:\n            model_path (str): The path to the model used for configuring the pipeline.\n\n        Returns:\n            BasePipeline: A new instance of the pipeline, configured with the given model.\n        \"\"\"\n        pipeline = cls()\n        pipeline.configure_pipeline(model_path)\n\n        return pipeline\n\n    @abstractmethod\n    def configure_pipeline(self, model_path: str) -&gt; None:\n        \"\"\"\n        Configure the pipeline based on the provided model path.\n\n        This method should be implemented by subclasses to add specific components\n        and configure the pipeline according to the given model.\n\n        Args:\n            model_path (str): The path to the model used for configuring the pipeline.\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the method is not implemented by a subclass.\n        \"\"\"\n        raise NotImplementedError(\"This method must be implemented by subclasses.\")\n\n    @property\n    def stages(self):\n        \"\"\"\n        Returns a human-readable representation of the pipeline stages.\n        \"\"\"\n        output = [\"Pipeline Stages:\"]\n        for stage, components in self._stages.items():\n            output.append(f\"  {stage}:\")\n            for component in components:\n                component_name = (\n                    component.__name__\n                    if hasattr(component, \"__name__\")\n                    else (\n                        component.__class__.__name__\n                        if hasattr(component, \"__class__\")\n                        else str(component)\n                    )\n                )\n                output.append(f\"    - {component_name}\")\n        if not self._stages:\n            output.append(\"  No stages defined.\")\n        return \"\\n\".join(output)\n\n    @stages.setter\n    def stages(self, new_stages: Dict[str, List[Callable]]):\n        \"\"\"\n        Sets the stages of the pipeline.\n\n        Args:\n            new_stages (Dict[str, List[Callable]]): A dictionary where keys are stage names\n                                                    and values are lists of callable components.\n        \"\"\"\n        self._stages = new_stages\n\n    def add_input(self, connector: BaseConnector[T]) -&gt; None:\n        \"\"\"\n        Adds an input connector to the pipeline.\n\n        This method sets the input connector for the pipeline, which is responsible\n        for processing the input data before it's passed to the pipeline components.\n\n        Args:\n            connector (Connector[T]): The input connector to be added to the pipeline.\n\n        Returns:\n            None\n\n        Note:\n            Only one input connector can be set for the pipeline. If this method is\n            called multiple times, the last connector will overwrite the previous ones.\n        \"\"\"\n        self._input_connector = connector\n\n    def add_output(self, connector: BaseConnector[T]) -&gt; None:\n        \"\"\"\n        Adds an output connector to the pipeline.\n\n        This method sets the output connector for the pipeline, which is responsible\n        for processing the output data after it has passed through all pipeline components.\n\n        Args:\n            connector (Connector[T]): The output connector to be added to the pipeline.\n\n        Returns:\n            None\n\n        Note:\n            Only one output connector can be set for the pipeline. If this method is\n            called multiple times, the last connector will overwrite the previous ones.\n        \"\"\"\n        self._output_connector = connector\n\n    def add_node(\n        self,\n        component: Union[\n            BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n        ] = None,\n        *,\n        position: PositionType = \"default\",\n        reference: str = None,\n        stage: str = None,\n        name: str = None,\n        input_model: Type[BaseModel] = None,\n        output_model: Type[BaseModel] = None,\n        dependencies: List[str] = [],\n    ) -&gt; None:\n        \"\"\"\n        Adds a component node to the pipeline.\n\n        Args:\n            component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]], optional):\n                The component to be added. It can be either a BaseComponent object or a callable function.\n                Defaults to None.\n            position (PositionType, optional):\n                The position at which the component should be added in the pipeline.\n                Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\".\n                Defaults to \"default\".\n            reference (str, optional):\n                The name of the component after or before which the new component should be added.\n                Only applicable when position is \"after\" or \"before\".\n                Defaults to None.\n            stage (str, optional):\n                The stage to which the component belongs.\n                Defaults to None.\n            name (str, optional):\n                The name of the component.\n                Defaults to None, in which case the name of the function will be used.\n            input_model (Type[BaseModel], optional):\n                The input Pydantic model class for validating the input data.\n                Defaults to None.\n            output_model (Type[BaseModel], optional):\n                The output Pydantic model class for validating the output data.\n                Defaults to None.\n            dependencies (List[str], optional):\n                The list of component names that this component depends on.\n                Defaults to an empty list.\n\n        Returns:\n            The original component if component is None, otherwise the wrapper function.\n\n        \"\"\"\n\n        def wrapper(func):\n            def validated_component(data: DataContainer[T]) -&gt; DataContainer[T]:\n                # Validate input if input_model is provided\n                if input_model:\n                    input_model(**data.__dict__)\n\n                # Run the component\n                result = func(data)\n\n                # Validate output if output_model is provided\n                if output_model:\n                    output_model(**result.__dict__)\n\n                return result\n\n            component_func = (\n                validated_component if input_model or output_model else func\n            )\n            new_component = PipelineNode(\n                func=component_func,\n                position=position,\n                reference=reference,\n                stage=stage,\n                name=name\n                if name is not None\n                else (\n                    component_func.__name__\n                    if hasattr(component_func, \"__name__\")\n                    else (\n                        component_func.__class__.__name__\n                        if hasattr(component_func, \"__class__\")\n                        else str(component_func)\n                    )\n                ),\n                dependencies=dependencies,\n            )\n            try:\n                self._add_component_at_position(new_component, position, reference)\n            except Exception as e:\n                raise ValueError(f\"Error adding component: {str(e)}\")\n\n            if stage:\n                if stage not in self._stages:\n                    self._stages[stage] = []\n                self._stages[stage].append(func)\n                logger.debug(\n                    f\"Successfully added component '{new_component.name}' to stage '{stage}'.\"\n                )\n\n            return func\n\n        if component is None:\n            return wrapper\n        if callable(component):\n            return wrapper(component)\n        else:\n            raise ValueError(\"Component must be callable\")\n\n    def _add_component_at_position(self, new_component, position, reference):\n        \"\"\"\n        Add a new component to the pipeline at a specified position.\n\n        Args:\n            new_component (PipelineNode): The new component to be added to the pipeline.\n            position (str): The position where the component should be added.\n                            Valid values are 'first', 'last', 'after', 'before', or 'default'.\n            reference (str, optional): The name of the reference component when using 'after' or 'before' positions.\n\n        Raises:\n            ValueError: If an invalid position is provided or if a reference is required but not provided.\n\n        This method handles the insertion of a new component into the pipeline based on the specified position:\n        - 'first': Inserts the component at the beginning of the pipeline.\n        - 'last' or 'default': Appends the component to the end of the pipeline.\n        - 'after' or 'before': Inserts the component relative to a reference component.\n\n        For 'after' and 'before' positions, a reference component name must be provided.\n        \"\"\"\n        if position == \"first\":\n            self._components.insert(0, new_component)\n        elif position in [\"last\", \"default\"]:\n            self._components.append(new_component)\n        elif position in [\"after\", \"before\"]:\n            if not reference:\n                raise ValueError(\n                    f\"Reference must be provided for position '{position}'.\"\n                )\n            offset = 1 if position == \"after\" else 0\n            self._insert_relative_position(new_component, reference, offset)\n        else:\n            raise ValueError(\n                f\"Invalid position '{position}'. Must be 'first', 'last', 'after', 'before', or 'default'.\"\n            )\n\n    def _insert_relative_position(self, component, reference, offset):\n        \"\"\"\n        Insert a component relative to a reference component in the pipeline.\n\n        Args:\n            component (PipelineNode): The component to be inserted.\n            reference (str): The name of the reference component.\n            offset (int): The offset from the reference component (0 for before, 1 for after).\n\n        Raises:\n            ValueError: If the reference component is not found in the pipeline.\n        \"\"\"\n        ref_index = next(\n            (i for i, c in enumerate(self._components) if c.name == reference), None\n        )\n        if ref_index is None:\n            raise ValueError(f\"Reference component '{reference}' not found.\")\n\n        self._components.insert(ref_index + offset, component)\n\n    def remove(self, component_name: str) -&gt; None:\n        \"\"\"\n        Removes a component from the pipeline.\n\n        Args:\n            component_name (str): The name of the component to be removed.\n\n        Raises:\n            ValueError: If the component is not found in the pipeline.\n\n        Returns:\n            None\n\n        Logs:\n            DEBUG: When the component is successfully removed.\n            WARNING: If the component fails to be removed after attempting to do so.\n        \"\"\"\n        # Check if the component exists in the pipeline\n        if not any(c.name == component_name for c in self._components):\n            raise ValueError(f\"Component '{component_name}' not found in the pipeline.\")\n\n        # Remove the component from self.components\n        original_count = len(self._components)\n        self._components = [c for c in self._components if c.name != component_name]\n\n        # Remove the component from stages\n        for stage in self._stages.values():\n            stage[:] = [c for c in stage if c.__name__ != component_name]\n\n        # Validate that the component was removed\n        if len(self._components) == original_count or any(\n            c.__name__ == component_name\n            for stage in self._stages.values()\n            for c in stage\n        ):\n            logger.warning(\n                f\"Failed to remove component '{component_name}' from the pipeline.\"\n            )\n        logger.debug(\n            f\"Successfully removed component '{component_name}' from the pipeline.\"\n        )\n\n    def replace(\n        self,\n        old_component_name: str,\n        new_component: Union[\n            BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n        ],\n    ) -&gt; None:\n        \"\"\"\n        Replaces a component in the pipeline with a new component.\n\n        Args:\n            old_component_name (str): The name of the component to be replaced.\n            new_component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]):\n                The new component to replace the old component with.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the old component is not found in the pipeline.\n            ValueError: If the new component is not a BaseComponent or a callable.\n            ValueError: If the new component callable doesn't have the correct signature.\n\n        Logs:\n            DEBUG: When the component is successfully replaced.\n        \"\"\"\n\n        if isinstance(new_component, BaseComponent):\n            # It's a valid BaseComponent, no further checks needed\n            pass\n        elif callable(new_component):\n            sig = signature(new_component)\n            param = list(sig.parameters.values())[0]\n            if len(sig.parameters) != 1 or not issubclass(\n                param.annotation, DataContainer\n            ):\n                raise ValueError(\n                    \"New component callable must accept a single argument that is a subclass of DataContainer.\"\n                )\n        else:\n            raise ValueError(\"New component must be a BaseComponent or a callable.\")\n\n        old_component_found = False\n\n        # Replace in self.components\n        for i, c in enumerate(self._components):\n            if c.name == old_component_name:\n                self._components[i] = PipelineNode(\n                    func=new_component,\n                    name=old_component_name,\n                    position=c.position,\n                    reference=c.reference,\n                    stage=c.stage,\n                    dependencies=c.dependencies,\n                )\n                old_component_found = True\n\n        # Replace in self.stages\n        for stage in self._stages.values():\n            for i, c in enumerate(stage):\n                if getattr(c, \"name\", c.__name__) == old_component_name:\n                    stage[i] = new_component\n                    old_component_found = True\n\n        if not old_component_found:\n            raise ValueError(\n                f\"Component '{old_component_name}' not found in the pipeline.\"\n            )\n        else:\n            logger.debug(\n                f\"Successfully replaced component '{old_component_name}' in the pipeline.\"\n            )\n\n    def __call__(self, data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n        if self._built_pipeline is None:\n            self._built_pipeline = self.build()\n        return self._built_pipeline(data)\n\n    def build(self) -&gt; Callable:\n        \"\"\"\n        Builds and returns a pipeline function that applies a series of components to the input data.\n        Returns:\n            pipeline: A function that takes input data and applies the ordered components to it.\n        Raises:\n            ValueError: If a circular dependency is detected among the components.\n        \"\"\"\n\n        def resolve_dependencies():\n            resolved = []\n            unresolved = self._components.copy()\n\n            while unresolved:\n                for component in unresolved:\n                    if all(\n                        dep in [c.name for c in resolved]\n                        for dep in component.dependencies\n                    ):\n                        resolved.append(component)\n                        unresolved.remove(component)\n                        break\n                else:\n                    raise ValueError(\"Circular dependency detected\")\n\n            return [c.func for c in resolved]\n\n        ordered_components = resolve_dependencies()\n\n        def pipeline(data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n            if self._input_connector:\n                data = self._input_connector.input(data)\n\n            if not isinstance(data, DataContainer):\n                data = DataContainer(data)\n\n            data = reduce(lambda d, comp: comp(d), ordered_components, data)\n            if self._output_connector:\n                data = self._output_connector.output(data)\n\n            return data\n\n        if self._built_pipeline is not pipeline:\n            self._built_pipeline = pipeline\n\n        return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.stages","title":"<code>stages</code>  <code>property</code> <code>writable</code>","text":"<p>Returns a human-readable representation of the pipeline stages.</p>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.add_input","title":"<code>add_input(connector)</code>","text":"<p>Adds an input connector to the pipeline.</p> <p>This method sets the input connector for the pipeline, which is responsible for processing the input data before it's passed to the pipeline components.</p> PARAMETER DESCRIPTION <code>connector</code> <p>The input connector to be added to the pipeline.</p> <p> TYPE: <code>Connector[T]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Note <p>Only one input connector can be set for the pipeline. If this method is called multiple times, the last connector will overwrite the previous ones.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def add_input(self, connector: BaseConnector[T]) -&gt; None:\n    \"\"\"\n    Adds an input connector to the pipeline.\n\n    This method sets the input connector for the pipeline, which is responsible\n    for processing the input data before it's passed to the pipeline components.\n\n    Args:\n        connector (Connector[T]): The input connector to be added to the pipeline.\n\n    Returns:\n        None\n\n    Note:\n        Only one input connector can be set for the pipeline. If this method is\n        called multiple times, the last connector will overwrite the previous ones.\n    \"\"\"\n    self._input_connector = connector\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.add_node","title":"<code>add_node(component=None, *, position='default', reference=None, stage=None, name=None, input_model=None, output_model=None, dependencies=[])</code>","text":"<p>Adds a component node to the pipeline.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component to be added. It can be either a BaseComponent object or a callable function. Defaults to None.</p> <p> TYPE: <code>Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]</code> DEFAULT: <code>None</code> </p> <code>position</code> <p>The position at which the component should be added in the pipeline. Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\". Defaults to \"default\".</p> <p> TYPE: <code>PositionType</code> DEFAULT: <code>'default'</code> </p> <code>reference</code> <p>The name of the component after or before which the new component should be added. Only applicable when position is \"after\" or \"before\". Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>stage</code> <p>The stage to which the component belongs. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>The name of the component. Defaults to None, in which case the name of the function will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>input_model</code> <p>The input Pydantic model class for validating the input data. Defaults to None.</p> <p> TYPE: <code>Type[BaseModel]</code> DEFAULT: <code>None</code> </p> <code>output_model</code> <p>The output Pydantic model class for validating the output data. Defaults to None.</p> <p> TYPE: <code>Type[BaseModel]</code> DEFAULT: <code>None</code> </p> <code>dependencies</code> <p>The list of component names that this component depends on. Defaults to an empty list.</p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>[]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>The original component if component is None, otherwise the wrapper function.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def add_node(\n    self,\n    component: Union[\n        BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n    ] = None,\n    *,\n    position: PositionType = \"default\",\n    reference: str = None,\n    stage: str = None,\n    name: str = None,\n    input_model: Type[BaseModel] = None,\n    output_model: Type[BaseModel] = None,\n    dependencies: List[str] = [],\n) -&gt; None:\n    \"\"\"\n    Adds a component node to the pipeline.\n\n    Args:\n        component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]], optional):\n            The component to be added. It can be either a BaseComponent object or a callable function.\n            Defaults to None.\n        position (PositionType, optional):\n            The position at which the component should be added in the pipeline.\n            Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\".\n            Defaults to \"default\".\n        reference (str, optional):\n            The name of the component after or before which the new component should be added.\n            Only applicable when position is \"after\" or \"before\".\n            Defaults to None.\n        stage (str, optional):\n            The stage to which the component belongs.\n            Defaults to None.\n        name (str, optional):\n            The name of the component.\n            Defaults to None, in which case the name of the function will be used.\n        input_model (Type[BaseModel], optional):\n            The input Pydantic model class for validating the input data.\n            Defaults to None.\n        output_model (Type[BaseModel], optional):\n            The output Pydantic model class for validating the output data.\n            Defaults to None.\n        dependencies (List[str], optional):\n            The list of component names that this component depends on.\n            Defaults to an empty list.\n\n    Returns:\n        The original component if component is None, otherwise the wrapper function.\n\n    \"\"\"\n\n    def wrapper(func):\n        def validated_component(data: DataContainer[T]) -&gt; DataContainer[T]:\n            # Validate input if input_model is provided\n            if input_model:\n                input_model(**data.__dict__)\n\n            # Run the component\n            result = func(data)\n\n            # Validate output if output_model is provided\n            if output_model:\n                output_model(**result.__dict__)\n\n            return result\n\n        component_func = (\n            validated_component if input_model or output_model else func\n        )\n        new_component = PipelineNode(\n            func=component_func,\n            position=position,\n            reference=reference,\n            stage=stage,\n            name=name\n            if name is not None\n            else (\n                component_func.__name__\n                if hasattr(component_func, \"__name__\")\n                else (\n                    component_func.__class__.__name__\n                    if hasattr(component_func, \"__class__\")\n                    else str(component_func)\n                )\n            ),\n            dependencies=dependencies,\n        )\n        try:\n            self._add_component_at_position(new_component, position, reference)\n        except Exception as e:\n            raise ValueError(f\"Error adding component: {str(e)}\")\n\n        if stage:\n            if stage not in self._stages:\n                self._stages[stage] = []\n            self._stages[stage].append(func)\n            logger.debug(\n                f\"Successfully added component '{new_component.name}' to stage '{stage}'.\"\n            )\n\n        return func\n\n    if component is None:\n        return wrapper\n    if callable(component):\n        return wrapper(component)\n    else:\n        raise ValueError(\"Component must be callable\")\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.add_output","title":"<code>add_output(connector)</code>","text":"<p>Adds an output connector to the pipeline.</p> <p>This method sets the output connector for the pipeline, which is responsible for processing the output data after it has passed through all pipeline components.</p> PARAMETER DESCRIPTION <code>connector</code> <p>The output connector to be added to the pipeline.</p> <p> TYPE: <code>Connector[T]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Note <p>Only one output connector can be set for the pipeline. If this method is called multiple times, the last connector will overwrite the previous ones.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def add_output(self, connector: BaseConnector[T]) -&gt; None:\n    \"\"\"\n    Adds an output connector to the pipeline.\n\n    This method sets the output connector for the pipeline, which is responsible\n    for processing the output data after it has passed through all pipeline components.\n\n    Args:\n        connector (Connector[T]): The output connector to be added to the pipeline.\n\n    Returns:\n        None\n\n    Note:\n        Only one output connector can be set for the pipeline. If this method is\n        called multiple times, the last connector will overwrite the previous ones.\n    \"\"\"\n    self._output_connector = connector\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.build","title":"<code>build()</code>","text":"<p>Builds and returns a pipeline function that applies a series of components to the input data. Returns:     pipeline: A function that takes input data and applies the ordered components to it. Raises:     ValueError: If a circular dependency is detected among the components.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def build(self) -&gt; Callable:\n    \"\"\"\n    Builds and returns a pipeline function that applies a series of components to the input data.\n    Returns:\n        pipeline: A function that takes input data and applies the ordered components to it.\n    Raises:\n        ValueError: If a circular dependency is detected among the components.\n    \"\"\"\n\n    def resolve_dependencies():\n        resolved = []\n        unresolved = self._components.copy()\n\n        while unresolved:\n            for component in unresolved:\n                if all(\n                    dep in [c.name for c in resolved]\n                    for dep in component.dependencies\n                ):\n                    resolved.append(component)\n                    unresolved.remove(component)\n                    break\n            else:\n                raise ValueError(\"Circular dependency detected\")\n\n        return [c.func for c in resolved]\n\n    ordered_components = resolve_dependencies()\n\n    def pipeline(data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n        if self._input_connector:\n            data = self._input_connector.input(data)\n\n        if not isinstance(data, DataContainer):\n            data = DataContainer(data)\n\n        data = reduce(lambda d, comp: comp(d), ordered_components, data)\n        if self._output_connector:\n            data = self._output_connector.output(data)\n\n        return data\n\n    if self._built_pipeline is not pipeline:\n        self._built_pipeline = pipeline\n\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.configure_pipeline","title":"<code>configure_pipeline(model_path)</code>  <code>abstractmethod</code>","text":"<p>Configure the pipeline based on the provided model path.</p> <p>This method should be implemented by subclasses to add specific components and configure the pipeline according to the given model.</p> PARAMETER DESCRIPTION <code>model_path</code> <p>The path to the model used for configuring the pipeline.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented by a subclass.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@abstractmethod\ndef configure_pipeline(self, model_path: str) -&gt; None:\n    \"\"\"\n    Configure the pipeline based on the provided model path.\n\n    This method should be implemented by subclasses to add specific components\n    and configure the pipeline according to the given model.\n\n    Args:\n        model_path (str): The path to the model used for configuring the pipeline.\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the method is not implemented by a subclass.\n    \"\"\"\n    raise NotImplementedError(\"This method must be implemented by subclasses.\")\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.load","title":"<code>load(model_path)</code>  <code>classmethod</code>","text":"<p>Load and configure a pipeline from a given model path.</p> <p>This class method creates a new instance of the pipeline, configures it using the provided model path, and returns the configured pipeline.</p> PARAMETER DESCRIPTION <code>model_path</code> <p>The path to the model used for configuring the pipeline.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>BasePipeline</code> <p>A new instance of the pipeline, configured with the given model.</p> <p> TYPE: <code>BasePipeline</code> </p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@classmethod\ndef load(cls, model_path: str) -&gt; \"BasePipeline\":\n    \"\"\"\n    Load and configure a pipeline from a given model path.\n\n    This class method creates a new instance of the pipeline, configures it\n    using the provided model path, and returns the configured pipeline.\n\n    Args:\n        model_path (str): The path to the model used for configuring the pipeline.\n\n    Returns:\n        BasePipeline: A new instance of the pipeline, configured with the given model.\n    \"\"\"\n    pipeline = cls()\n    pipeline.configure_pipeline(model_path)\n\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.remove","title":"<code>remove(component_name)</code>","text":"<p>Removes a component from the pipeline.</p> PARAMETER DESCRIPTION <code>component_name</code> <p>The name of the component to be removed.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the component is not found in the pipeline.</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Logs <p>DEBUG: When the component is successfully removed. WARNING: If the component fails to be removed after attempting to do so.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def remove(self, component_name: str) -&gt; None:\n    \"\"\"\n    Removes a component from the pipeline.\n\n    Args:\n        component_name (str): The name of the component to be removed.\n\n    Raises:\n        ValueError: If the component is not found in the pipeline.\n\n    Returns:\n        None\n\n    Logs:\n        DEBUG: When the component is successfully removed.\n        WARNING: If the component fails to be removed after attempting to do so.\n    \"\"\"\n    # Check if the component exists in the pipeline\n    if not any(c.name == component_name for c in self._components):\n        raise ValueError(f\"Component '{component_name}' not found in the pipeline.\")\n\n    # Remove the component from self.components\n    original_count = len(self._components)\n    self._components = [c for c in self._components if c.name != component_name]\n\n    # Remove the component from stages\n    for stage in self._stages.values():\n        stage[:] = [c for c in stage if c.__name__ != component_name]\n\n    # Validate that the component was removed\n    if len(self._components) == original_count or any(\n        c.__name__ == component_name\n        for stage in self._stages.values()\n        for c in stage\n    ):\n        logger.warning(\n            f\"Failed to remove component '{component_name}' from the pipeline.\"\n        )\n    logger.debug(\n        f\"Successfully removed component '{component_name}' from the pipeline.\"\n    )\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.replace","title":"<code>replace(old_component_name, new_component)</code>","text":"<p>Replaces a component in the pipeline with a new component.</p> PARAMETER DESCRIPTION <code>old_component_name</code> <p>The name of the component to be replaced.</p> <p> TYPE: <code>str</code> </p> <code>new_component</code> <p>The new component to replace the old component with.</p> <p> TYPE: <code>Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the old component is not found in the pipeline.</p> <code>ValueError</code> <p>If the new component is not a BaseComponent or a callable.</p> <code>ValueError</code> <p>If the new component callable doesn't have the correct signature.</p> Logs <p>DEBUG: When the component is successfully replaced.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def replace(\n    self,\n    old_component_name: str,\n    new_component: Union[\n        BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n    ],\n) -&gt; None:\n    \"\"\"\n    Replaces a component in the pipeline with a new component.\n\n    Args:\n        old_component_name (str): The name of the component to be replaced.\n        new_component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]):\n            The new component to replace the old component with.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the old component is not found in the pipeline.\n        ValueError: If the new component is not a BaseComponent or a callable.\n        ValueError: If the new component callable doesn't have the correct signature.\n\n    Logs:\n        DEBUG: When the component is successfully replaced.\n    \"\"\"\n\n    if isinstance(new_component, BaseComponent):\n        # It's a valid BaseComponent, no further checks needed\n        pass\n    elif callable(new_component):\n        sig = signature(new_component)\n        param = list(sig.parameters.values())[0]\n        if len(sig.parameters) != 1 or not issubclass(\n            param.annotation, DataContainer\n        ):\n            raise ValueError(\n                \"New component callable must accept a single argument that is a subclass of DataContainer.\"\n            )\n    else:\n        raise ValueError(\"New component must be a BaseComponent or a callable.\")\n\n    old_component_found = False\n\n    # Replace in self.components\n    for i, c in enumerate(self._components):\n        if c.name == old_component_name:\n            self._components[i] = PipelineNode(\n                func=new_component,\n                name=old_component_name,\n                position=c.position,\n                reference=c.reference,\n                stage=c.stage,\n                dependencies=c.dependencies,\n            )\n            old_component_found = True\n\n    # Replace in self.stages\n    for stage in self._stages.values():\n        for i, c in enumerate(stage):\n            if getattr(c, \"name\", c.__name__) == old_component_name:\n                stage[i] = new_component\n                old_component_found = True\n\n    if not old_component_found:\n        raise ValueError(\n            f\"Component '{old_component_name}' not found in the pipeline.\"\n        )\n    else:\n        logger.debug(\n            f\"Successfully replaced component '{old_component_name}' in the pipeline.\"\n        )\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.Pipeline","title":"<code>Pipeline</code>","text":"<p>               Bases: <code>BasePipeline</code>, <code>Generic[T]</code></p> <p>Default Pipeline class for creating a basic data processing pipeline. This class inherits from BasePipeline and provides a default implementation of the configure_pipeline method, which does not add any specific components.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>class Pipeline(BasePipeline, Generic[T]):\n    \"\"\"\n    Default Pipeline class for creating a basic data processing pipeline.\n    This class inherits from BasePipeline and provides a default implementation\n    of the configure_pipeline method, which does not add any specific components.\n    \"\"\"\n\n    def configure_pipeline(self, model_path: str) -&gt; None:\n        \"\"\"\n        Configures the pipeline by adding components based on the provided model path.\n        This default implementation does not add any specific components.\n\n        Args:\n            model_path (str): The path to the model used for configuring the pipeline.\n        \"\"\"\n        # Default implementation: No specific components added\n        pass\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.Pipeline.configure_pipeline","title":"<code>configure_pipeline(model_path)</code>","text":"<p>Configures the pipeline by adding components based on the provided model path. This default implementation does not add any specific components.</p> PARAMETER DESCRIPTION <code>model_path</code> <p>The path to the model used for configuring the pipeline.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def configure_pipeline(self, model_path: str) -&gt; None:\n    \"\"\"\n    Configures the pipeline by adding components based on the provided model path.\n    This default implementation does not add any specific components.\n\n    Args:\n        model_path (str): The path to the model used for configuring the pipeline.\n    \"\"\"\n    # Default implementation: No specific components added\n    pass\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.PipelineNode","title":"<code>PipelineNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Represents a node in a pipeline.</p> ATTRIBUTE DESCRIPTION <code>func</code> <p>The function to be applied to the data.</p> <p> TYPE: <code>Callable[[DataContainer[T]], DataContainer[T]]</code> </p> <code>position</code> <p>The position of the node in the pipeline. Defaults to \"default\".</p> <p> TYPE: <code>PositionType</code> </p> <code>reference</code> <p>The reference for the relative position of the node. Name should be the \"name\" attribute of another node. Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>stage</code> <p>The stage of the node in the pipeline. Group nodes by stage e.g. \"preprocessing\". Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of the node. Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>dependencies</code> <p>The list of dependencies for the node. Defaults to an empty list.</p> <p> TYPE: <code>List[str]</code> </p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@dataclass\nclass PipelineNode(Generic[T]):\n    \"\"\"\n    Represents a node in a pipeline.\n\n    Attributes:\n        func (Callable[[DataContainer[T]], DataContainer[T]]): The function to be applied to the data.\n        position (PositionType, optional): The position of the node in the pipeline. Defaults to \"default\".\n        reference (str, optional): The reference for the relative position of the node. Name should be the \"name\" attribute of another node. Defaults to None.\n        stage (str, optional): The stage of the node in the pipeline. Group nodes by stage e.g. \"preprocessing\". Defaults to None.\n        name (str, optional): The name of the node. Defaults to None.\n        dependencies (List[str], optional): The list of dependencies for the node. Defaults to an empty list.\n    \"\"\"\n\n    func: Callable[[DataContainer[T]], DataContainer[T]]\n    position: PositionType = \"default\"\n    reference: str = None\n    stage: str = None\n    name: str = None\n    dependencies: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/service/","title":"Service","text":""},{"location":"api/service/#healthchain.service.service.Service","title":"<code>Service</code>","text":"<p>A service wrapper which registers routes and starts a FastAPI service</p> <p>Parameters: endpoints (Dict[str, Enpoint]): the list of endpoints to register, must be a dictionary of Endpoint objects. Should have human-readable keys e.g. [\"info\", \"service_mount\"]</p> Source code in <code>healthchain/service/service.py</code> <pre><code>class Service:\n    \"\"\"\n    A service wrapper which registers routes and starts a FastAPI service\n\n    Parameters:\n    endpoints (Dict[str, Enpoint]): the list of endpoints to register, must be a dictionary\n    of Endpoint objects. Should have human-readable keys e.g. [\"info\", \"service_mount\"]\n\n    \"\"\"\n\n    def __init__(self, endpoints: Dict[str, Endpoint] = None):\n        self.app = FastAPI(lifespan=self.lifespan)\n        self.endpoints: Endpoint = endpoints\n\n        if self.endpoints is not None:\n            self._register_routes()\n\n        # Router to handle stopping the server\n        self.stop_router = APIRouter()\n        self.stop_router.add_api_route(\n            \"/shutdown\", self._shutdown, methods=[\"GET\"], include_in_schema=False\n        )\n        self.app.include_router(self.stop_router)\n\n    def _register_routes(self) -&gt; None:\n        # TODO: add kwargs\n        for endpoint in self.endpoints.values():\n            if endpoint.api_protocol == ApiProtocol.soap:\n                wsgi_app = start_wsgi(endpoint.function)\n                self.app.mount(endpoint.path, WSGIMiddleware(wsgi_app))\n            else:\n                self.app.add_api_route(\n                    endpoint.path,\n                    endpoint.function,\n                    methods=[endpoint.method],\n                    response_model_exclude_none=True,\n                )\n\n    @asynccontextmanager\n    async def lifespan(self, app: FastAPI):\n        self._startup()\n        yield\n        self._shutdown()\n\n    def _startup(self) -&gt; None:\n        healthchain_ascii = r\"\"\"\n\n    __  __           ____  __    ________          _\n   / / / /__  ____ _/ / /_/ /_  / ____/ /_  ____ _(_)___\n  / /_/ / _ \\/ __ `/ / __/ __ \\/ /   / __ \\/ __ `/ / __ \\\n / __  /  __/ /_/ / / /_/ / / / /___/ / / / /_/ / / / / /\n/_/ /_/\\___/\\__,_/_/\\__/_/ /_/\\____/_/ /_/\\__,_/_/_/ /_/\n\n\"\"\"  # noqa: E501\n\n        colors = [\"red\", \"yellow\", \"green\", \"cyan\", \"blue\", \"magenta\"]\n        for i, line in enumerate(healthchain_ascii.split(\"\\n\")):\n            color = colors[i % len(colors)]\n            print(colored(line, color))\n        for endpoint in self.endpoints.values():\n            print(\n                f\"{colored('HEALTHCHAIN', 'green')}: {endpoint.method} endpoint at {endpoint.path}/\"\n            )\n        print(\n            f\"{colored('HEALTHCHAIN', 'green')}: See more details at {colored(self.app.docs_url, 'magenta')}\"\n        )\n\n    def _shutdown(self):\n        \"\"\"\n        Shuts down server\n        \"\"\"\n        os.kill(os.getpid(), signal.SIGTERM)\n        return JSONResponse(content={\"message\": \"Server is shutting down...\"})\n\n    def run(self, config: Dict = None) -&gt; None:\n        \"\"\"\n        Starts server on uvicorn.\n\n        Parameters:\n        config (Dict): kwargs to pass into uvicorn.\n\n        \"\"\"\n        if config is None:\n            config = {}\n\n        uvicorn.run(self.app, **config)\n</code></pre>"},{"location":"api/service/#healthchain.service.service.Service.run","title":"<code>run(config=None)</code>","text":"<p>Starts server on uvicorn.</p> <p>Parameters: config (Dict): kwargs to pass into uvicorn.</p> Source code in <code>healthchain/service/service.py</code> <pre><code>def run(self, config: Dict = None) -&gt; None:\n    \"\"\"\n    Starts server on uvicorn.\n\n    Parameters:\n    config (Dict): kwargs to pass into uvicorn.\n\n    \"\"\"\n    if config is None:\n        config = {}\n\n    uvicorn.run(self.app, **config)\n</code></pre>"},{"location":"api/use_cases/","title":"Use Cases","text":""},{"location":"api/use_cases/#healthchain.use_cases.cds.ClinicalDecisionSupport","title":"<code>ClinicalDecisionSupport</code>","text":"<p>               Bases: <code>BaseUseCase</code></p> <p>Implements EHR backend simulator for Clinical Decision Support (CDS)</p> PARAMETER DESCRIPTION <code>service_api</code> <p>the function body to inject into the main service</p> <p> TYPE: <code>APIMethod</code> DEFAULT: <code>None</code> </p> <code>service_config</code> <p>the config kwargs for the uvicorn server passed into service</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>service</code> <p>the service runner object</p> <p> TYPE: <code>Service</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>the client runner object</p> <p> TYPE: <code>BaseClient</code> DEFAULT: <code>None</code> </p> <p>See https://cds-hooks.org/ for specification</p> Source code in <code>healthchain/use_cases/cds.py</code> <pre><code>class ClinicalDecisionSupport(BaseUseCase):\n    \"\"\"\n    Implements EHR backend simulator for Clinical Decision Support (CDS)\n\n    Parameters:\n        service_api (APIMethod): the function body to inject into the main service\n        service_config (Dict): the config kwargs for the uvicorn server passed into service\n        service (Service): the service runner object\n        client (BaseClient): the client runner object\n\n    See https://cds-hooks.org/ for specification\n    \"\"\"\n\n    def __init__(\n        self,\n        service_api: Optional[APIMethod] = None,\n        service_config: Optional[Dict] = None,\n        service: Optional[Service] = None,\n        client: Optional[BaseClient] = None,\n    ) -&gt; None:\n        super().__init__(\n            service_api=service_api,\n            service_config=service_config,\n            service=service,\n            client=client,\n        )\n        self._type = UseCaseType.cds\n        self._strategy = ClinicalDecisionSupportStrategy()\n        # do we need keys? just in case\n        # TODO make configurable\n        self._endpoints = {\n            \"info\": Endpoint(\n                path=\"/cds-services\",\n                method=\"GET\",\n                function=self.cds_discovery,\n                api_protocol=\"REST\",\n            ),\n            \"service_mount\": Endpoint(\n                path=\"/cds-services/{id}\",\n                method=\"POST\",\n                function=self.cds_service,\n                api_protocol=\"REST\",\n            ),\n        }\n\n    @property\n    def description(self) -&gt; str:\n        return \"Clinical decision support (HL7 CDS specification)\"\n\n    @property\n    def type(self) -&gt; UseCaseType:\n        return self._type\n\n    @property\n    def strategy(self) -&gt; BaseStrategy:\n        return self._strategy\n\n    @property\n    def endpoints(self) -&gt; Dict[str, Endpoint]:\n        return self._endpoints\n\n    def cds_discovery(self) -&gt; CDSServiceInformation:\n        \"\"\"\n        CDS discovery endpoint for FastAPI app, should be mounted to /cds-services\n        \"\"\"\n        if self._client is None:\n            log.warning(\"CDS 'client' not configured, check class init.\")\n            return CDSServiceInformation(services=[])\n\n        service_info = CDSService(\n            hook=self._client.workflow.value,\n            description=\"A test CDS hook service.\",\n            id=\"1\",\n        )\n        return CDSServiceInformation(services=[service_info])\n\n    def cds_service(self, id: str, request: CDSRequest) -&gt; CDSResponse:\n        \"\"\"\n        CDS service endpoint for FastAPI app, mounted to /cds-services/{id}\n\n        This method handles the execution of a specific CDS service. It validates the\n        service configuration, checks the input parameters, executes the service\n        function, and ensures the correct response type is returned.\n\n        Args:\n            id (str): The unique identifier of the CDS service to be executed.\n            request (CDSRequest): The request object containing the input data for the CDS service.\n\n        Returns:\n            CDSResponse: The response object containing the cards generated by the CDS service.\n\n        Raises:\n            AssertionError: If the service function is not properly configured.\n            TypeError: If the input or output types do not match the expected types.\n\n        Note:\n            This method performs several checks to ensure the integrity of the service:\n            1. Verifies that the service API is configured.\n            2. Validates the signature of the service function.\n            3. Ensures the service function accepts a CDSRequest as its first argument.\n            4. Verifies that the service function returns a CDSResponse.\n        \"\"\"\n        # TODO: can register multiple services and fetch with id\n\n        # Check service_api\n        if self._service_api is None:\n            log.warning(\"CDS 'service_api' not configured, check class init.\")\n            return CDSResponse(cards=[])\n\n        # Check that the first argument of self._service_api.func is of type CDSRequest\n        func_signature = inspect.signature(self._service_api.func)\n        params = list(func_signature.parameters.values())\n        if len(params) &lt; 2:  # Only 'self' parameter\n            raise AssertionError(\n                \"Service function must have at least one parameter besides 'self'\"\n            )\n        first_param = params[1]  # Skip 'self'\n        if first_param.annotation == inspect.Parameter.empty:\n            log.warning(\n                \"Service function parameter has no type annotation. Expected CDSRequest.\"\n            )\n        elif first_param.annotation != CDSRequest:\n            raise TypeError(\n                f\"Expected first argument of service function to be CDSRequest, but got {first_param.annotation}\"\n            )\n\n        # Call the service function\n        response = self._service_api.func(self, request)\n\n        # Check that response is of type CDSResponse\n        if not isinstance(response, CDSResponse):\n            raise TypeError(f\"Expected CDSResponse, but got {type(response).__name__}\")\n\n        return response\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.cds.ClinicalDecisionSupport.cds_discovery","title":"<code>cds_discovery()</code>","text":"<p>CDS discovery endpoint for FastAPI app, should be mounted to /cds-services</p> Source code in <code>healthchain/use_cases/cds.py</code> <pre><code>def cds_discovery(self) -&gt; CDSServiceInformation:\n    \"\"\"\n    CDS discovery endpoint for FastAPI app, should be mounted to /cds-services\n    \"\"\"\n    if self._client is None:\n        log.warning(\"CDS 'client' not configured, check class init.\")\n        return CDSServiceInformation(services=[])\n\n    service_info = CDSService(\n        hook=self._client.workflow.value,\n        description=\"A test CDS hook service.\",\n        id=\"1\",\n    )\n    return CDSServiceInformation(services=[service_info])\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.cds.ClinicalDecisionSupport.cds_service","title":"<code>cds_service(id, request)</code>","text":"<p>CDS service endpoint for FastAPI app, mounted to /cds-services/{id}</p> <p>This method handles the execution of a specific CDS service. It validates the service configuration, checks the input parameters, executes the service function, and ensures the correct response type is returned.</p> PARAMETER DESCRIPTION <code>id</code> <p>The unique identifier of the CDS service to be executed.</p> <p> TYPE: <code>str</code> </p> <code>request</code> <p>The request object containing the input data for the CDS service.</p> <p> TYPE: <code>CDSRequest</code> </p> RETURNS DESCRIPTION <code>CDSResponse</code> <p>The response object containing the cards generated by the CDS service.</p> <p> TYPE: <code>CDSResponse</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the service function is not properly configured.</p> <code>TypeError</code> <p>If the input or output types do not match the expected types.</p> Note <p>This method performs several checks to ensure the integrity of the service: 1. Verifies that the service API is configured. 2. Validates the signature of the service function. 3. Ensures the service function accepts a CDSRequest as its first argument. 4. Verifies that the service function returns a CDSResponse.</p> Source code in <code>healthchain/use_cases/cds.py</code> <pre><code>def cds_service(self, id: str, request: CDSRequest) -&gt; CDSResponse:\n    \"\"\"\n    CDS service endpoint for FastAPI app, mounted to /cds-services/{id}\n\n    This method handles the execution of a specific CDS service. It validates the\n    service configuration, checks the input parameters, executes the service\n    function, and ensures the correct response type is returned.\n\n    Args:\n        id (str): The unique identifier of the CDS service to be executed.\n        request (CDSRequest): The request object containing the input data for the CDS service.\n\n    Returns:\n        CDSResponse: The response object containing the cards generated by the CDS service.\n\n    Raises:\n        AssertionError: If the service function is not properly configured.\n        TypeError: If the input or output types do not match the expected types.\n\n    Note:\n        This method performs several checks to ensure the integrity of the service:\n        1. Verifies that the service API is configured.\n        2. Validates the signature of the service function.\n        3. Ensures the service function accepts a CDSRequest as its first argument.\n        4. Verifies that the service function returns a CDSResponse.\n    \"\"\"\n    # TODO: can register multiple services and fetch with id\n\n    # Check service_api\n    if self._service_api is None:\n        log.warning(\"CDS 'service_api' not configured, check class init.\")\n        return CDSResponse(cards=[])\n\n    # Check that the first argument of self._service_api.func is of type CDSRequest\n    func_signature = inspect.signature(self._service_api.func)\n    params = list(func_signature.parameters.values())\n    if len(params) &lt; 2:  # Only 'self' parameter\n        raise AssertionError(\n            \"Service function must have at least one parameter besides 'self'\"\n        )\n    first_param = params[1]  # Skip 'self'\n    if first_param.annotation == inspect.Parameter.empty:\n        log.warning(\n            \"Service function parameter has no type annotation. Expected CDSRequest.\"\n        )\n    elif first_param.annotation != CDSRequest:\n        raise TypeError(\n            f\"Expected first argument of service function to be CDSRequest, but got {first_param.annotation}\"\n        )\n\n    # Call the service function\n    response = self._service_api.func(self, request)\n\n    # Check that response is of type CDSResponse\n    if not isinstance(response, CDSResponse):\n        raise TypeError(f\"Expected CDSResponse, but got {type(response).__name__}\")\n\n    return response\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.cds.ClinicalDecisionSupportStrategy","title":"<code>ClinicalDecisionSupportStrategy</code>","text":"<p>               Bases: <code>BaseStrategy</code></p> <p>Handles the request construction and validation</p> Source code in <code>healthchain/use_cases/cds.py</code> <pre><code>class ClinicalDecisionSupportStrategy(BaseStrategy):\n    \"\"\"\n    Handles the request construction and validation\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.api_protocol = ApiProtocol.rest\n        self.context_mapping = {\n            Workflow.order_select: OrderSelectContext,\n            Workflow.order_sign: OrderSignContext,\n            Workflow.patient_view: PatientViewContext,\n            Workflow.encounter_discharge: EncounterDischargeContext,\n        }\n\n    @validate_workflow(UseCaseMapping.ClinicalDecisionSupport)\n    def construct_request(self, data: CdsFhirData, workflow: Workflow) -&gt; CDSRequest:\n        \"\"\"\n        Constructs a HL7-compliant CDS request based on workflow.\n\n        Parameters:\n            data: FHIR data to be injected in request.\n            workflow (Workflow): The CDS hook name, e.g. patient-view.\n\n        Returns:\n            CDSRequest: A Pydantic model that wraps a CDS request for REST\n\n        Raises:\n            ValueError: If the workflow is invalid or the data does not validate properly.\n        \"\"\"\n        log.debug(f\"Constructing CDS request for {workflow.value} from {data}\")\n\n        context_model = self.context_mapping.get(workflow, None)\n        if context_model is None:\n            raise ValueError(\n                f\"Invalid workflow {workflow.value} or workflow model not implemented.\"\n            )\n        if not isinstance(data, CdsFhirData):\n            raise TypeError(\n                f\"CDS clients must return data of type CdsFhirData, not {type(data)}\"\n            )\n\n        # i feel like theres a better way to do this\n        request_data = data.model_dump()\n        request = CDSRequest(\n            hook=workflow.value,\n            context=context_model(**request_data.get(\"context\", {})),\n            prefetch=request_data.get(\"prefetch\"),\n        )\n\n        return request\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.cds.ClinicalDecisionSupportStrategy.construct_request","title":"<code>construct_request(data, workflow)</code>","text":"<p>Constructs a HL7-compliant CDS request based on workflow.</p> PARAMETER DESCRIPTION <code>data</code> <p>FHIR data to be injected in request.</p> <p> TYPE: <code>CdsFhirData</code> </p> <code>workflow</code> <p>The CDS hook name, e.g. patient-view.</p> <p> TYPE: <code>Workflow</code> </p> RETURNS DESCRIPTION <code>CDSRequest</code> <p>A Pydantic model that wraps a CDS request for REST</p> <p> TYPE: <code>CDSRequest</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the workflow is invalid or the data does not validate properly.</p> Source code in <code>healthchain/use_cases/cds.py</code> <pre><code>@validate_workflow(UseCaseMapping.ClinicalDecisionSupport)\ndef construct_request(self, data: CdsFhirData, workflow: Workflow) -&gt; CDSRequest:\n    \"\"\"\n    Constructs a HL7-compliant CDS request based on workflow.\n\n    Parameters:\n        data: FHIR data to be injected in request.\n        workflow (Workflow): The CDS hook name, e.g. patient-view.\n\n    Returns:\n        CDSRequest: A Pydantic model that wraps a CDS request for REST\n\n    Raises:\n        ValueError: If the workflow is invalid or the data does not validate properly.\n    \"\"\"\n    log.debug(f\"Constructing CDS request for {workflow.value} from {data}\")\n\n    context_model = self.context_mapping.get(workflow, None)\n    if context_model is None:\n        raise ValueError(\n            f\"Invalid workflow {workflow.value} or workflow model not implemented.\"\n        )\n    if not isinstance(data, CdsFhirData):\n        raise TypeError(\n            f\"CDS clients must return data of type CdsFhirData, not {type(data)}\"\n        )\n\n    # i feel like theres a better way to do this\n    request_data = data.model_dump()\n    request = CDSRequest(\n        hook=workflow.value,\n        context=context_model(**request_data.get(\"context\", {})),\n        prefetch=request_data.get(\"prefetch\"),\n    )\n\n    return request\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.requests.cdsrequest.CDSRequest","title":"<code>CDSRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A model representing the data structure for a CDS service call, triggered by specific hooks within a healthcare application.</p> ATTRIBUTE DESCRIPTION <code>hook</code> <p>The hook that triggered this CDS Service call. For example, 'patient-view'.</p> <p> TYPE: <code>str</code> </p> <code>hookInstance</code> <p>A universally unique identifier for this particular hook call.</p> <p> TYPE: <code>UUID</code> </p> <code>fhirServer</code> <p>The base URL of the CDS Client's FHIR server. This field is required if <code>fhirAuthorization</code> is provided.</p> <p> TYPE: <code>HttpUrl</code> </p> <code>fhirAuthorization</code> <p>Optional authorization details providing a bearer access token for FHIR resources.</p> <p> TYPE: <code>Optional[FhirAuthorization]</code> </p> <code>context</code> <p>Hook-specific contextual data required by the CDS service.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>prefetch</code> <p>Optional FHIR data that was prefetched by the CDS Client.</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#http-request_1</p> Source code in <code>healthchain/models/requests/cdsrequest.py</code> <pre><code>class CDSRequest(BaseModel):\n    \"\"\"\n    A model representing the data structure for a CDS service call, triggered by specific hooks\n    within a healthcare application.\n\n    Attributes:\n        hook (str): The hook that triggered this CDS Service call. For example, 'patient-view'.\n        hookInstance (UUID): A universally unique identifier for this particular hook call.\n        fhirServer (HttpUrl): The base URL of the CDS Client's FHIR server. This field is required if `fhirAuthorization` is provided.\n        fhirAuthorization (Optional[FhirAuthorization]): Optional authorization details providing a bearer access token for FHIR resources.\n        context (Dict[str, Any]): Hook-specific contextual data required by the CDS service.\n        prefetch (Optional[Dict[str, Any]]): Optional FHIR data that was prefetched by the CDS Client.\n\n    Documentation: https://cds-hooks.org/specification/current/#http-request_1\n    \"\"\"\n\n    hook: str\n    hookInstance: str = Field(default_factory=id_generator.generate_random_uuid)\n    context: BaseHookContext\n    fhirServer: Optional[HttpUrl] = None\n    fhirAuthorization: Optional[FHIRAuthorization] = (\n        None  # TODO: note this is required if fhirserver is given\n    )\n    prefetch: Optional[Dict[str, Any]] = (\n        None  # fhir resource is passed either thru prefetched template of fhir server\n    )\n    extension: Optional[List[Dict[str, Any]]] = None\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.Action","title":"<code>Action</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Within a suggestion, all actions are logically AND'd together, such that a user selecting a suggestion selects all of the actions within it. When a suggestion contains multiple actions, the actions SHOULD be processed as per FHIR's rules for processing transactions with the CDS Client's fhirServer as the base url for the inferred full URL of the transaction bundle entries.</p> <p>https://cds-hooks.org/specification/current/#action</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Action(BaseModel):\n    \"\"\"\n    Within a suggestion, all actions are logically AND'd together, such that a user selecting a\n    suggestion selects all of the actions within it. When a suggestion contains multiple actions,\n    the actions SHOULD be processed as per FHIR's rules for processing transactions with the CDS\n    Client's fhirServer as the base url for the inferred full URL of the transaction bundle entries.\n\n    https://cds-hooks.org/specification/current/#action\n    \"\"\"\n\n    type: ActionTypeEnum\n    description: str\n    resource: Optional[Dict] = None\n    resourceId: Optional[str] = None\n\n    @model_validator(mode=\"after\")\n    def validate_action_type(self) -&gt; Self:\n        if self.type in [ActionTypeEnum.create, ActionTypeEnum.update]:\n            assert (\n                self.resource\n            ), f\"'resource' must be provided when type is '{self.type.value}'\"\n        else:\n            assert (\n                self.resourceId\n            ), f\"'resourceId' must be provided when type is '{self.type.value}'\"\n\n        return self\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.ActionTypeEnum","title":"<code>ActionTypeEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of action being performed</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class ActionTypeEnum(str, Enum):\n    \"\"\"\n    The type of action being performed\n    \"\"\"\n\n    create = \"create\"\n    update = \"update\"\n    delete = \"delete\"\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.CDSResponse","title":"<code>CDSResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the response from a CDS service.</p> <p>This class models the structure of a CDS Hooks response, which includes cards for displaying information or suggestions to the user, and optional system actions that can be executed automatically.</p> ATTRIBUTE DESCRIPTION <code>cards</code> <p>A list of Card objects to be displayed to the end user. Default is an empty list.</p> <p> TYPE: <code>List[Card]</code> </p> <code>systemActions</code> <p>A list of Action objects representing actions that the CDS Client should execute as part of performing the decision support requested. This field is optional.</p> <p> TYPE: <code>Optional[List[Action]]</code> </p> <p>For more information, see: https://cds-hooks.org/specification/current/#cds-service-response</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class CDSResponse(BaseModel):\n    \"\"\"\n    Represents the response from a CDS service.\n\n    This class models the structure of a CDS Hooks response, which includes\n    cards for displaying information or suggestions to the user, and optional\n    system actions that can be executed automatically.\n\n    Attributes:\n        cards (List[Card]): A list of Card objects to be displayed to the end user.\n            Default is an empty list.\n        systemActions (Optional[List[Action]]): A list of Action objects representing\n            actions that the CDS Client should execute as part of performing\n            the decision support requested. This field is optional.\n\n    For more information, see:\n    https://cds-hooks.org/specification/current/#cds-service-response\n    \"\"\"\n\n    cards: List[Card] = []\n    systemActions: Optional[List[Action]] = None\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.Card","title":"<code>Card</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Cards can provide a combination of information (for reading), suggested actions (to be applied if a user selects them), and links (to launch an app if the user selects them). The CDS Client decides how to display cards, but this specification recommends displaying suggestions using buttons, and links using underlined text.</p> <p>https://cds-hooks.org/specification/current/#card-attributes</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Card(BaseModel):\n    \"\"\"\n    Cards can provide a combination of information (for reading), suggested actions\n    (to be applied if a user selects them), and links (to launch an app if the user selects them).\n    The CDS Client decides how to display cards, but this specification recommends displaying suggestions\n    using buttons, and links using underlined text.\n\n    https://cds-hooks.org/specification/current/#card-attributes\n    \"\"\"\n\n    summary: str = Field(..., max_length=140)\n    indicator: IndicatorEnum\n    source: Source\n    uuid: Optional[str] = None\n    detail: Optional[str] = None\n    suggestions: Optional[List[Suggestion]] = None\n    selectionBehavior: Optional[SelectionBehaviorEnum] = None\n    overrideReasons: Optional[List[SimpleCoding]] = None\n    links: Optional[List[Link]] = None\n\n    @model_validator(mode=\"after\")\n    def validate_suggestions(self) -&gt; Self:\n        if self.suggestions is not None:\n            assert self.selectionBehavior, f\"'selectionBehavior' must be given if 'suggestions' is present! Choose from {[v for v in SelectionBehaviorEnum.value]}\"\n        return self\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.IndicatorEnum","title":"<code>IndicatorEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Urgency/importance of what Card conveys. Allowed values, in order of increasing urgency, are: info, warning, critical. The CDS Client MAY use this field to help make UI display decisions such as sort order or coloring.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class IndicatorEnum(str, Enum):\n    \"\"\"\n    Urgency/importance of what Card conveys.\n    Allowed values, in order of increasing urgency, are: info, warning, critical.\n    The CDS Client MAY use this field to help make UI display decisions such as sort order or coloring.\n    \"\"\"\n\n    info = \"info\"\n    warning = \"warning\"\n    critical = \"critical\"\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.Link","title":"<code>Link</code>","text":"<p>               Bases: <code>BaseModel</code></p> <ul> <li> <p>CDS Client support for appContext requires additional coordination with the authorization server that is not described or specified in CDS Hooks nor SMART.</p> </li> <li> <p>Autolaunchable is experimental</p> </li> </ul> <p>https://cds-hooks.org/specification/current/#link</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Link(BaseModel):\n    \"\"\"\n    * CDS Client support for appContext requires additional coordination with the authorization\n    server that is not described or specified in CDS Hooks nor SMART.\n\n    * Autolaunchable is experimental\n\n    https://cds-hooks.org/specification/current/#link\n    \"\"\"\n\n    label: str\n    url: HttpUrl\n    type: LinkTypeEnum\n    appContext: Optional[str] = None\n    autoLaunchable: Optional[bool]\n\n    @model_validator(mode=\"after\")\n    def validate_link(self) -&gt; Self:\n        if self.appContext:\n            assert (\n                self.type == LinkTypeEnum.smart\n            ), \"'type' must be 'smart' for appContext to be valued.\"\n\n        return self\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.LinkTypeEnum","title":"<code>LinkTypeEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of the given URL. There are two possible values for this field. A type of absolute indicates that the URL is absolute and should be treated as-is. A type of smart indicates that the URL is a SMART app launch URL and the CDS Client should ensure the SMART app launch URL is populated with the appropriate SMART launch parameters.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class LinkTypeEnum(str, Enum):\n    \"\"\"\n    The type of the given URL. There are two possible values for this field.\n    A type of absolute indicates that the URL is absolute and should be treated as-is.\n    A type of smart indicates that the URL is a SMART app launch URL and the CDS Client\n    should ensure the SMART app launch URL is populated with the appropriate SMART\n    launch parameters.\n    \"\"\"\n\n    absolute = \"absolute\"\n    smart = \"smart\"\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.SelectionBehaviorEnum","title":"<code>SelectionBehaviorEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Describes the intended selection behavior of the suggestions in the card. Allowed values are: at-most-one, indicating that the user may choose none or at most one of the suggestions; any, indicating that the end user may choose any number of suggestions including none of them and all of them. CDS Clients that do not understand the value MUST treat the card as an error.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class SelectionBehaviorEnum(str, Enum):\n    \"\"\"\n    Describes the intended selection behavior of the suggestions in the card.\n    Allowed values are: at-most-one, indicating that the user may choose none or\n    at most one of the suggestions; any, indicating that the end user may choose\n    any number of suggestions including none of them and all of them.\n    CDS Clients that do not understand the value MUST treat the card as an error.\n    \"\"\"\n\n    at_most_one = \"at-most-one\"\n    any = \"any\"\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.SimpleCoding","title":"<code>SimpleCoding</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The Coding data type captures the concept of a code. This coding type is a standalone data type in CDS Hooks modeled after a trimmed down version of the FHIR Coding data type.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class SimpleCoding(BaseModel):\n    \"\"\"\n    The Coding data type captures the concept of a code. This coding type is a standalone data type\n    in CDS Hooks modeled after a trimmed down version of the FHIR Coding data type.\n    \"\"\"\n\n    code: str\n    system: str\n    display: Optional[str] = None\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.Source","title":"<code>Source</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Grouping structure for the Source of the information displayed on this card. The source should be the primary source of guidance for the decision support Card represents.</p> <p>https://cds-hooks.org/specification/current/#source</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Source(BaseModel):\n    \"\"\"\n    Grouping structure for the Source of the information displayed on this card.\n    The source should be the primary source of guidance for the decision support Card represents.\n\n    https://cds-hooks.org/specification/current/#source\n    \"\"\"\n\n    label: str\n    url: Optional[HttpUrl] = None\n    icon: Optional[HttpUrl] = None\n    topic: Optional[SimpleCoding] = None\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.Suggestion","title":"<code>Suggestion</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Allows a service to suggest a set of changes in the context of the current activity (e.g. changing the dose of a medication currently being prescribed, for the order-sign activity). If suggestions are present, selectionBehavior MUST also be provided.</p> <p>https://cds-hooks.org/specification/current/#suggestion</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Suggestion(BaseModel):\n    \"\"\"\n    Allows a service to suggest a set of changes in the context of the current activity\n    (e.g. changing the dose of a medication currently being prescribed, for the order-sign activity).\n    If suggestions are present, selectionBehavior MUST also be provided.\n\n    https://cds-hooks.org/specification/current/#suggestion\n    \"\"\"\n\n    label: str\n    uuid: Optional[str] = None\n    isRecommended: Optional[bool]\n    actions: Optional[List[Action]] = []\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.clindoc.ClinicalDocumentation","title":"<code>ClinicalDocumentation</code>","text":"<p>               Bases: <code>BaseUseCase</code></p> <p>Implements EHR backend strategy for clinical documentation (NoteReader)</p> <p>This class represents the backend strategy for clinical documentation using the NoteReader system. It inherits from the <code>BaseUseCase</code> class and provides methods for processing NoteReader documents.</p> ATTRIBUTE DESCRIPTION <code>service_api</code> <p>The service API method to be used for processing the documents.</p> <p> TYPE: <code>Optional[APIMethod]</code> </p> <code>service_config</code> <p>The configuration for the service.</p> <p> TYPE: <code>Optional[Dict]</code> </p> <code>service</code> <p>The service to be used for processing the documents.</p> <p> TYPE: <code>Optional[Service]</code> </p> <code>client</code> <p>The client to be used for communication with the service.</p> <p> TYPE: <code>Optional[BaseClient]</code> </p> <code>overwrite</code> <p>Whether to overwrite existing data in the CDA document.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>healthchain/use_cases/clindoc.py</code> <pre><code>class ClinicalDocumentation(BaseUseCase):\n    \"\"\"\n    Implements EHR backend strategy for clinical documentation (NoteReader)\n\n    This class represents the backend strategy for clinical documentation using the NoteReader system.\n    It inherits from the `BaseUseCase` class and provides methods for processing NoteReader documents.\n\n    Attributes:\n        service_api (Optional[APIMethod]): The service API method to be used for processing the documents.\n        service_config (Optional[Dict]): The configuration for the service.\n        service (Optional[Service]): The service to be used for processing the documents.\n        client (Optional[BaseClient]): The client to be used for communication with the service.\n        overwrite (bool): Whether to overwrite existing data in the CDA document.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        service_api: Optional[APIMethod] = None,\n        service_config: Optional[Dict] = None,\n        service: Optional[Service] = None,\n        client: Optional[BaseClient] = None,\n    ) -&gt; None:\n        super().__init__(\n            service_api=service_api,\n            service_config=service_config,\n            service=service,\n            client=client,\n        )\n        self._type = UseCaseType.clindoc\n        self._strategy = ClinicalDocumentationStrategy()\n        self._endpoints = {\n            \"service_mount\": Endpoint(\n                path=\"/notereader/\",\n                method=\"POST\",\n                function=self.process_notereader_document,\n                api_protocol=\"SOAP\",\n            )\n        }\n        self.overwrite: bool = False\n\n    @property\n    def description(self) -&gt; str:\n        return \"Clinical documentation (NoteReader)\"\n\n    @property\n    def type(self) -&gt; UseCaseType:\n        return self._type\n\n    @property\n    def strategy(self) -&gt; BaseStrategy:\n        return self._strategy\n\n    @property\n    def endpoints(self) -&gt; Dict[str, Endpoint]:\n        return self._endpoints\n\n    def process_notereader_document(self, request: CdaRequest) -&gt; CdaResponse:\n        \"\"\"\n        Process the NoteReader document using the configured service API.\n\n        This method handles the execution of the NoteReader service. It validates the\n        service configuration, checks the input parameters, executes the service\n        function, and ensures the correct response type is returned.\n\n        Args:\n            request (CdaRequest): The request object containing the CDA document to be processed.\n\n        Returns:\n            CdaResponse: The response object containing the processed CDA document.\n\n        Raises:\n            AssertionError: If the service function is not properly configured.\n            TypeError: If the output type does not match the expected CdaResponse type.\n\n        Note:\n            This method performs several checks to ensure the integrity of the service:\n            1. Verifies that the service API is configured.\n            2. Validates the signature of the service function.\n            3. Ensures the service function accepts a CdaRequest as its argument.\n            4. Verifies that the service function returns a CdaResponse.\n        \"\"\"\n        # Check service_api\n        if self._service_api is None:\n            log.warning(\"'service_api' not configured, check class init.\")\n            return CdaResponse(document=\"\")\n\n        # Check service function signature\n        signature = inspect.signature(self._service_api.func)\n        params = list(signature.parameters.values())\n        if len(params) &lt; 2:  # Only 'self' parameter\n            raise AssertionError(\n                \"Service function must have at least one parameter besides 'self'\"\n            )\n        first_param = params[1]  # Skip 'self'\n        if first_param.annotation == inspect.Parameter.empty:\n            log.warning(\n                \"Service function parameter has no type annotation. Expected CdaRequest.\"\n            )\n        elif first_param.annotation != CdaRequest:\n            raise TypeError(\n                f\"Expected first argument of service function to be CdaRequest, but got {first_param.annotation}\"\n            )\n\n        # Call the service function\n        response = self._service_api.func(self, request)\n\n        # Check return type\n        if not isinstance(response, CdaResponse):\n            raise TypeError(\n                f\"Expected return type CdaResponse, got {type(response)} instead.\"\n            )\n\n        return response\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.clindoc.ClinicalDocumentation.process_notereader_document","title":"<code>process_notereader_document(request)</code>","text":"<p>Process the NoteReader document using the configured service API.</p> <p>This method handles the execution of the NoteReader service. It validates the service configuration, checks the input parameters, executes the service function, and ensures the correct response type is returned.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request object containing the CDA document to be processed.</p> <p> TYPE: <code>CdaRequest</code> </p> RETURNS DESCRIPTION <code>CdaResponse</code> <p>The response object containing the processed CDA document.</p> <p> TYPE: <code>CdaResponse</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the service function is not properly configured.</p> <code>TypeError</code> <p>If the output type does not match the expected CdaResponse type.</p> Note <p>This method performs several checks to ensure the integrity of the service: 1. Verifies that the service API is configured. 2. Validates the signature of the service function. 3. Ensures the service function accepts a CdaRequest as its argument. 4. Verifies that the service function returns a CdaResponse.</p> Source code in <code>healthchain/use_cases/clindoc.py</code> <pre><code>def process_notereader_document(self, request: CdaRequest) -&gt; CdaResponse:\n    \"\"\"\n    Process the NoteReader document using the configured service API.\n\n    This method handles the execution of the NoteReader service. It validates the\n    service configuration, checks the input parameters, executes the service\n    function, and ensures the correct response type is returned.\n\n    Args:\n        request (CdaRequest): The request object containing the CDA document to be processed.\n\n    Returns:\n        CdaResponse: The response object containing the processed CDA document.\n\n    Raises:\n        AssertionError: If the service function is not properly configured.\n        TypeError: If the output type does not match the expected CdaResponse type.\n\n    Note:\n        This method performs several checks to ensure the integrity of the service:\n        1. Verifies that the service API is configured.\n        2. Validates the signature of the service function.\n        3. Ensures the service function accepts a CdaRequest as its argument.\n        4. Verifies that the service function returns a CdaResponse.\n    \"\"\"\n    # Check service_api\n    if self._service_api is None:\n        log.warning(\"'service_api' not configured, check class init.\")\n        return CdaResponse(document=\"\")\n\n    # Check service function signature\n    signature = inspect.signature(self._service_api.func)\n    params = list(signature.parameters.values())\n    if len(params) &lt; 2:  # Only 'self' parameter\n        raise AssertionError(\n            \"Service function must have at least one parameter besides 'self'\"\n        )\n    first_param = params[1]  # Skip 'self'\n    if first_param.annotation == inspect.Parameter.empty:\n        log.warning(\n            \"Service function parameter has no type annotation. Expected CdaRequest.\"\n        )\n    elif first_param.annotation != CdaRequest:\n        raise TypeError(\n            f\"Expected first argument of service function to be CdaRequest, but got {first_param.annotation}\"\n        )\n\n    # Call the service function\n    response = self._service_api.func(self, request)\n\n    # Check return type\n    if not isinstance(response, CdaResponse):\n        raise TypeError(\n            f\"Expected return type CdaResponse, got {type(response)} instead.\"\n        )\n\n    return response\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.clindoc.ClinicalDocumentationStrategy","title":"<code>ClinicalDocumentationStrategy</code>","text":"<p>               Bases: <code>BaseStrategy</code></p> <p>Handles the request construction and validation of a NoteReader CDA file</p> Source code in <code>healthchain/use_cases/clindoc.py</code> <pre><code>class ClinicalDocumentationStrategy(BaseStrategy):\n    \"\"\"\n    Handles the request construction and validation of a NoteReader CDA file\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.api_protocol: ApiProtocol = ApiProtocol.soap\n        self.soap_envelope: Dict = self._load_soap_envelope()\n\n    def _load_soap_envelope(self):\n        data = pkgutil.get_data(\"healthchain\", \"templates/soap_envelope.xml\")\n        return xmltodict.parse(data.decode(\"utf-8\"))\n\n    def construct_cda_xml_document(self):\n        \"\"\"\n        This function should wrap FHIR data from CcdFhirData into a template CDA file (dep. vendor\n        TODO: implement this function\n        \"\"\"\n        pass\n\n    @validate_workflow(UseCaseMapping.ClinicalDocumentation)\n    def construct_request(self, data: CcdData, workflow: Workflow) -&gt; CdaRequest:\n        \"\"\"\n        Constructs a CDA request for clinical documentation use cases (NoteReader)\n\n        Parameters:\n            data: CDA data to be injected in the request\n            workflow (Workflow): The NoteReader workflow type, e.g. notereader-sign-inpatient\n\n        Returns:\n            CdaRequest: A Pydantic model that wraps CDA data for SOAP request\n\n        Raises:\n            ValueError: If the workflow is invalid or the data does not validate properly.\n        \"\"\"\n        # TODO: handle converting fhir data from data generator to cda\n        # TODO: handle different workflows\n        if data.cda_xml is not None:\n            # Encode the cda xml in base64\n            encoded_xml = base64.b64encode(data.cda_xml.encode(\"utf-8\")).decode(\"utf-8\")\n\n            # Make a copy of the SOAP envelope template\n            soap_envelope = self.soap_envelope.copy()\n\n            # Insert encoded cda in the Document section\n            if not insert_at_key(soap_envelope, \"urn:Document\", encoded_xml):\n                raise ValueError(\n                    \"Key 'urn:Document' missing from SOAP envelope template!\"\n                )\n            request = CdaRequest.from_dict(soap_envelope)\n\n            return request\n        else:\n            log.warning(\n                \"Data generation methods for CDA documents not implemented yet!\"\n            )\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.clindoc.ClinicalDocumentationStrategy.construct_cda_xml_document","title":"<code>construct_cda_xml_document()</code>","text":"<p>This function should wrap FHIR data from CcdFhirData into a template CDA file (dep. vendor TODO: implement this function</p> Source code in <code>healthchain/use_cases/clindoc.py</code> <pre><code>def construct_cda_xml_document(self):\n    \"\"\"\n    This function should wrap FHIR data from CcdFhirData into a template CDA file (dep. vendor\n    TODO: implement this function\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.clindoc.ClinicalDocumentationStrategy.construct_request","title":"<code>construct_request(data, workflow)</code>","text":"<p>Constructs a CDA request for clinical documentation use cases (NoteReader)</p> PARAMETER DESCRIPTION <code>data</code> <p>CDA data to be injected in the request</p> <p> TYPE: <code>CcdData</code> </p> <code>workflow</code> <p>The NoteReader workflow type, e.g. notereader-sign-inpatient</p> <p> TYPE: <code>Workflow</code> </p> RETURNS DESCRIPTION <code>CdaRequest</code> <p>A Pydantic model that wraps CDA data for SOAP request</p> <p> TYPE: <code>CdaRequest</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the workflow is invalid or the data does not validate properly.</p> Source code in <code>healthchain/use_cases/clindoc.py</code> <pre><code>@validate_workflow(UseCaseMapping.ClinicalDocumentation)\ndef construct_request(self, data: CcdData, workflow: Workflow) -&gt; CdaRequest:\n    \"\"\"\n    Constructs a CDA request for clinical documentation use cases (NoteReader)\n\n    Parameters:\n        data: CDA data to be injected in the request\n        workflow (Workflow): The NoteReader workflow type, e.g. notereader-sign-inpatient\n\n    Returns:\n        CdaRequest: A Pydantic model that wraps CDA data for SOAP request\n\n    Raises:\n        ValueError: If the workflow is invalid or the data does not validate properly.\n    \"\"\"\n    # TODO: handle converting fhir data from data generator to cda\n    # TODO: handle different workflows\n    if data.cda_xml is not None:\n        # Encode the cda xml in base64\n        encoded_xml = base64.b64encode(data.cda_xml.encode(\"utf-8\")).decode(\"utf-8\")\n\n        # Make a copy of the SOAP envelope template\n        soap_envelope = self.soap_envelope.copy()\n\n        # Insert encoded cda in the Document section\n        if not insert_at_key(soap_envelope, \"urn:Document\", encoded_xml):\n            raise ValueError(\n                \"Key 'urn:Document' missing from SOAP envelope template!\"\n            )\n        request = CdaRequest.from_dict(soap_envelope)\n\n        return request\n    else:\n        log.warning(\n            \"Data generation methods for CDA documents not implemented yet!\"\n        )\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.requests.cdarequest.CdaRequest","title":"<code>CdaRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>class CdaRequest(BaseModel):\n    document: str\n\n    @classmethod\n    def from_dict(cls, data: Dict):\n        \"\"\"\n        Loads data from dict (xmltodict format)\n        \"\"\"\n        return cls(document=xmltodict.unparse(data))\n\n    def model_dump(self, *args, **kwargs) -&gt; Dict:\n        \"\"\"\n        Dumps document as dict with xmltodict\n        \"\"\"\n        return xmltodict.parse(self.document)\n\n    def model_dump_xml(self, *args, **kwargs) -&gt; str:\n        \"\"\"\n        Decodes and dumps document as an xml string\n        \"\"\"\n        xml_dict = xmltodict.parse(self.document)\n        document = search_key(xml_dict, \"urn:Document\")\n        if document is None:\n            log.warning(\"Coudln't find document under namespace 'urn:Document\")\n            return \"\"\n        cda = base64.b64decode(document).decode(\"UTF-8\")\n\n        return cda\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.requests.cdarequest.CdaRequest.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Loads data from dict (xmltodict format)</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict):\n    \"\"\"\n    Loads data from dict (xmltodict format)\n    \"\"\"\n    return cls(document=xmltodict.unparse(data))\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.requests.cdarequest.CdaRequest.model_dump","title":"<code>model_dump(*args, **kwargs)</code>","text":"<p>Dumps document as dict with xmltodict</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>def model_dump(self, *args, **kwargs) -&gt; Dict:\n    \"\"\"\n    Dumps document as dict with xmltodict\n    \"\"\"\n    return xmltodict.parse(self.document)\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.requests.cdarequest.CdaRequest.model_dump_xml","title":"<code>model_dump_xml(*args, **kwargs)</code>","text":"<p>Decodes and dumps document as an xml string</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>def model_dump_xml(self, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Decodes and dumps document as an xml string\n    \"\"\"\n    xml_dict = xmltodict.parse(self.document)\n    document = search_key(xml_dict, \"urn:Document\")\n    if document is None:\n        log.warning(\"Coudln't find document under namespace 'urn:Document\")\n        return \"\"\n    cda = base64.b64decode(document).decode(\"UTF-8\")\n\n    return cda\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdaresponse.CdaResponse","title":"<code>CdaResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>class CdaResponse(BaseModel):\n    document: str\n    error: Optional[str] = None\n\n    @classmethod\n    def from_dict(cls, data: Dict):\n        \"\"\"\n        Loads data from dict (xmltodict format)\n        \"\"\"\n        return cls(document=xmltodict.unparse(data))\n\n    def model_dump(self, *args, **kwargs) -&gt; Dict:\n        \"\"\"\n        Dumps document as dict with xmltodict\n        \"\"\"\n        return xmltodict.parse(self.document)\n\n    def model_dump_xml(self, *args, **kwargs) -&gt; str:\n        \"\"\"\n        Decodes and dumps document as an xml string\n        \"\"\"\n        xml_dict = xmltodict.parse(self.document)\n        document = search_key(xml_dict, \"tns:Document\")\n        if document is None:\n            log.warning(\"Couldn't find document under namespace 'tns:Document\")\n            return \"\"\n\n        cda = base64.b64decode(document).decode(\"UTF-8\")\n\n        return cda\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdaresponse.CdaResponse.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Loads data from dict (xmltodict format)</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict):\n    \"\"\"\n    Loads data from dict (xmltodict format)\n    \"\"\"\n    return cls(document=xmltodict.unparse(data))\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdaresponse.CdaResponse.model_dump","title":"<code>model_dump(*args, **kwargs)</code>","text":"<p>Dumps document as dict with xmltodict</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>def model_dump(self, *args, **kwargs) -&gt; Dict:\n    \"\"\"\n    Dumps document as dict with xmltodict\n    \"\"\"\n    return xmltodict.parse(self.document)\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdaresponse.CdaResponse.model_dump_xml","title":"<code>model_dump_xml(*args, **kwargs)</code>","text":"<p>Decodes and dumps document as an xml string</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>def model_dump_xml(self, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Decodes and dumps document as an xml string\n    \"\"\"\n    xml_dict = xmltodict.parse(self.document)\n    document = search_key(xml_dict, \"tns:Document\")\n    if document is None:\n        log.warning(\"Couldn't find document under namespace 'tns:Document\")\n        return \"\"\n\n    cda = base64.b64decode(document).decode(\"UTF-8\")\n\n    return cda\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"community/","title":"Community","text":""},{"location":"community/#contribute","title":"Contribute","text":"<p>Contributing Guidelines</p>"},{"location":"community/contribution_guide/","title":"Contribution Guide","text":""},{"location":"community/resources/","title":"Resources","text":""},{"location":"cookbook/","title":"Examples","text":"<p>The best way to learn is by example! Here are some to get you started:</p> <ul> <li>Build a CDS sandbox: Build a clinical decision support (CDS) system that uses patient-view to greet the patient.</li> <li>Build a Clinical Documentation sandbox: Build a NoteReader system which extracts problem, medication, and allergy concepts from free-text clinical notes.</li> </ul>"},{"location":"cookbook/cds_sandbox/","title":"Build a CDS sandbox","text":"<p>A CDS sandbox which uses <code>gpt-4o</code> to summarise patient information from synthetically generated FHIR resources received from the <code>patient-view</code> CDS hook. [NEEDS UPDATING]</p> <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.data_generators import CdsDataGenerator\nfrom healthchain.models import CdsFhirData, CDSRequest, CDSResponse\n\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\n\nfrom typing import List\n\n@hc.sandbox\nclass CdsSandbox(ClinicalDecisionSupport):\n  def __init__(self):\n    self.chain = self._init_llm_chain()\n    self.data_generator = CdsDataGenerator()\n\n  def _init_llm_chain(self):\n    prompt = PromptTemplate.from_template(\n      \"Extract conditions from the FHIR resource below and summarize in one sentence using simple language \\n'''{text}'''\"\n      )\n    model = ChatOpenAI(model=\"gpt-4o\")\n    parser = StrOutputParser()\n\n    chain = prompt | model | parser\n    return chain\n\n  @hc.ehr(workflow=\"patient-view\")\n  def load_data_in_client(self) -&gt; CdsFhirData:\n    data = self.data_generator.generate()\n    return data\n\n  @hc.api\n  def my_service(self, request: CDSRequest) -&gt; CDSResponse:\n    result = self.chain.invoke(str(request.prefetch))\n    return CDSResponse(\n      cards=[\n        Card(\n          summary=\"Patient summary\",\n          indicator=\"info\",\n          source={\"label\": \"openai\"},\n          detail=result,\n        )\n      ]\n    )\n</code></pre>"},{"location":"cookbook/notereader_sandbox/","title":"NoteReader Sandbox","text":"<p>A sandbox example of NoteReader clinical documentation improvement which extracts problems, medications, and allergies entries from the progress note section of a pre-configured CDA document.</p> <pre><code>import healthchain as hc\nfrom healthchain.use_cases import ClinicalDocumentation\nfrom healthchain.models import (\n    CcdData,\n    AllergyConcept,\n    Concept,\n    MedicationConcept,\n    ProblemConcept,\n    Quantity,\n)\n\n@hc.sandbox\nclass NotereaderSandbox(ClinicalDocumentation):\n  def __init__(self):\n      self.cda_path = \"./resources/uclh_cda.xml\"\n      self.pipeline = MedicalCodingPipeline.load(\"./resources/models/medcat_model.zip\")\n\n  @hc.ehr(workflow=\"sign-note-inpatient\")\n  def load_data_in_client(self) -&gt; CcdData:\n      with open(self.cda_path, \"r\") as file:\n          xml_string = file.read()\n\n      return CcdData(cda_xml=xml_string)\n\n  @hc.api\n  def my_service(self, request: CdaRequest) -&gt; CdaResponse:\n    response = self.pipeline(request)\n    return response\n</code></pre>"},{"location":"reference/","title":"Welcome!","text":""},{"location":"reference/pipeline/component/","title":"Component","text":"<p>Components are the building blocks of the healthchain pipeline. They are designed to process data in a consistent manner, allowing for easy composition and reusability.</p>"},{"location":"reference/pipeline/component/#available-components","title":"Available Components","text":"Component Description Methods <code>TextPreprocessor</code> Handles text preprocessing tasks <code>tokenizer</code>: Specifies the tokenization method (e.g., <code>\"basic\"</code> or <code>\"spacy\"</code>)  <code>lowercase</code>: Converts text to lowercase if <code>True</code> <code>remove_punctuation</code>: Removes punctuation if <code>True</code> <code>standardize_spaces</code>: Standardizes spaces if <code>True</code> <code>regex</code>: List of custom regex patterns and replacements <code>Model</code> Wraps machine learning and NLP models for use in the pipeline <code>load_model</code>: Loads the specified model <code>TextPostProcessor</code> Handles text postprocessing tasks <code>postcoordination_lookup</code>: Dictionary for entity refinement lookups"},{"location":"reference/pipeline/component/#creating-custom-components","title":"Creating Custom Components","text":"<p>You can create your own custom components by extending the <code>BaseComponent</code> class and implementing the <code>__call__</code> method.</p> <pre><code>from healthchain.pipeline.base import BaseComponent\n\nclass MyCustomComponent(BaseComponent):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    def __call__(self, data):\n        # Your custom processing logic here\n        return data\n</code></pre>"},{"location":"reference/pipeline/data_container/","title":"Data Container","text":"<p>The <code>healthchain.io.containers</code> module provides classes for storing and manipulating data throughout the pipeline. The main classes are <code>DataContainer</code>, <code>Document</code>, and <code>Tabular</code>.</p>"},{"location":"reference/pipeline/data_container/#datacontainer","title":"DataContainer","text":"<p><code>DataContainer</code> is a generic base class for storing data of any type.</p> <pre><code>from healthchain.io.containers import DataContainer\n\n# Create a DataContainer with string data\ncontainer = DataContainer(\"Some data\")\n\n# Convert to dictionary and JSON\ndata_dict = container.to_dict()\ndata_json = container.to_json()\n\n# Create from dictionary or JSON\ncontainer_from_dict = DataContainer.from_dict(data_dict)\ncontainer_from_json = DataContainer.from_json(data_json)\n</code></pre>"},{"location":"reference/pipeline/data_container/#document","title":"Document","text":"<p>The <code>Document</code> class is used to store and manipulate text data. It extends <code>DataContainer</code> and provides additional functionality for working with text, including integration with spaCy.</p> <pre><code>from healthchain.io.containers import Document\n\ndoc = Document(\"OpenAI released GPT-4 in 2023.\")\n\n# Basic text operations\nprint(f\"Char count: {doc.char_count()}\")\nprint(f\"Word count: {doc.word_count()}\")\n\n# Access tokens and entities (requires spaCy preprocessing)\nprint(f\"Tokens: {doc.tokens}\")\nprint(f\"Entities: {doc.get_entities()}\")\n\n# Iterate over tokens\nfor token in doc:\n    print(token)\n\n# Get document length (word count)\nprint(f\"Document length: {len(doc)}\")\n</code></pre> <p>Note: Some features like tokenization and entity recognition require setting a spaCy Doc object using a preprocessor. [TODO]</p>"},{"location":"reference/pipeline/data_container/#tabular","title":"Tabular","text":"<p>The <code>Tabular</code> class is used for storing and manipulating tabular data, wrapping a pandas DataFrame.</p> <pre><code>import pandas as pd\nfrom healthchain.io.containers import Tabular\n\n# Create a Tabular object from a DataFrame\ndf = pd.DataFrame({'A': [1, 2, 3], 'B': ['a', 'b', 'c']})\ntabular = Tabular(df)\n\n# Access basic information\nprint(f\"Columns: {tabular.columns}\")\nprint(f\"Row count: {tabular.row_count()}\")\nprint(f\"Column count: {tabular.column_count()}\")\nprint(f\"Data types: {tabular.dtypes}\")\n\n# Describe the tabular data\nprint(tabular.describe())\n\n# Remove a column\ntabular.remove_column('A')\n\n# Save to CSV\ntabular.to_csv('output.csv')\n\n# Create from CSV\ntabular_from_csv = Tabular.from_csv('input.csv')\n</code></pre> <p>These classes provide a consistent interface for working with different types of data in the healthchain pipeline.</p>"},{"location":"reference/pipeline/pipeline/","title":"Pipeline","text":"<p>HealthChain pipelines provide a simple interface to test, version, and connect your pipeline to common healthcare data standards, such as CDA (Clinical Document Architecture) and FHIR (Fast Healthcare Interoperability Resources).</p> <p>Depending on your need, you can either go top down, where you use prebuilt pipelines and customize them to your needs, or bottom up, where you build your own pipeline from scratch.</p>"},{"location":"reference/pipeline/pipeline/#prebuilt","title":"Prebuilt \ud83d\udce6","text":"<p>HealthChain comes with a set of prebuilt pipelines that are out-of-the-box implementations of common healthcare data processing tasks:</p> Pipeline Container Compatible Connector Description Example Use Case MedicalCodingPipeline <code>Document</code> <code>CdaConnector</code> An NLP pipeline that processes free-text clinical notes into structured data Automatically generating SNOMED CT codes from clinical notes SummarizationPipeline [TODO] <code>Document</code> <code>CdsFhirConnector</code> An NLP pipeline for summarizing clinical notes Generating discharge summaries from patient history and notes QAPipeline [TODO] <code>Document</code> N/A A Question Answering pipeline suitable for conversational AI applications Developing a chatbot to answer patient queries about their medical records ClassificationPipeline [TODO] <code>Tabular</code> <code>CdsFhirConnector</code> A pipeline for machine learning classification tasks Predicting patient readmission risk based on historical health data <p>Prebuilt pipelines are end-to-end workflows with Connectors built into them. They interact with raw data received from EHR interfaces, usually CDA or FHIR data from specific use cases.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.models import CdaRequest\n\npipeline = MedicalCodingPipeline.load('/path/to/model')\n\ncda_request = CdaRequest(document=\"&lt;Clinical Document&gt;\")\ncda_response = pipeline(cda_request)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#customizing-prebuilt-pipelines","title":"Customizing Prebuilt Pipelines","text":"<p>To customize a prebuilt pipeline, you can use the pipeline management methods to add, remove, and replace components. For example, you may want to change the model being used. [TODO]</p> <p>If you need more control and don't mind writing more code, you can subclass <code>BasePipeline</code> and implement your own pipeline logic.</p> <p>(BasePipeline API Reference)</p>"},{"location":"reference/pipeline/pipeline/#freestyle","title":"Freestyle \ud83d\udd7a","text":"<p>To build your own pipeline, you can start with an empty pipeline and add components to it. Initialize your pipeline with the appropriate container type, such as <code>Document</code> or <code>Tabular</code>. This is not essential, but it allows the pipeline to enforce type safety (If you don't specify the container type, it will be inferred from the first component added.)</p> <p>You can see the full list of available containers at the Container page.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io.containers import Document\n\npipeline = Pipeline[Document]()\n\n# Or if you live dangerously\n# pipeline = Pipeline()\n</code></pre> <p>To use a built pipeline, compile it by running <code>.build()</code>. This will return a compiled pipeline that you can run on your data.</p> <pre><code>pipe = pipeline.build()\ndoc = pipe(Document(\"Patient is diagnosed with diabetes\"))\n\nprint(doc.entities)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#adding-nodes","title":"Adding Nodes","text":"<p>There are three types of nodes you can add to your pipeline with the method <code>.add_node()</code>:</p> <ul> <li>Inline Functions</li> <li>Components</li> <li>Custom Components</li> </ul>"},{"location":"reference/pipeline/pipeline/#inline-functions","title":"Inline Functions","text":"<p>Inline functions are simple functions that take in a container and return a container.</p> <pre><code>@pipeline.add_node\ndef remove_stopwords(doc: Document) -&gt; Document:\n    stopwords = {\"the\", \"a\", \"an\", \"in\", \"on\", \"at\"}\n    doc.tokens = [token for token in doc.tokens if token not in stopwords]\n    return doc\n\n# Equivalent to:\npipeline.add_node(remove_stopwords)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#components","title":"Components","text":"<p>Components are pre-configured building blocks that perform specific tasks. They are defined as separate classes and can be reused across multiple pipelines.</p> <p>You can see the full list of available components at the Components page.</p> <pre><code>from healthchain.pipeline import TextPreProcessor\n\npreprocessor = TextPreProcessor(tokenizer=\"spacy\", lowercase=True)\npipeline.add_node(preprocessor)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#custom-components","title":"Custom Components","text":"<p>Custom components are classes that implement the <code>BaseComponent</code> interface. You can use them to add custom processing logic to your pipeline.</p> <pre><code>from healthchain.pipeline import BaseComponent\n\nclass RemoveStopwords(BaseComponent):\n    def __init__(self, stopwords: List[str]):\n        super().__init__()\n        self.stopwords = stopwords\n\n    def __call__(self, doc: Document) -&gt; Document:\n        doc.tokens = [token for token in doc.tokens if token not in self.stopwords]\n        return doc\n\nstopwords = [\"the\", \"a\", \"an\", \"in\", \"on\", \"at\"]\npipeline.add_node(RemoveStopwords(stopwords))\n</code></pre> <p>(BaseComponent API Reference)</p>"},{"location":"reference/pipeline/pipeline/#adding-connectors","title":"Adding Connectors \ud83d\udd17","text":"<p>Connectors are added to the pipeline using the <code>.add_input()</code> and <code>.add_output()</code> methods. You can learn more about connectors at the Connectors documentation page.</p> <pre><code>from healthchain.io import CdaConnector\n\ncda_connector = CdaConnector()\n\npipeline.add_input(cda_connector)\npipeline.add_output(cda_connector)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#pipeline-management","title":"Pipeline Management \ud83d\udd28","text":""},{"location":"reference/pipeline/pipeline/#adding","title":"Adding","text":"<p>Use <code>.add_node()</code> to add a component to the pipeline. By default, the component will be added to the end of the pipeline and named as the function name provided.</p> <p>You can specify the position of the component using the <code>position</code> parameter. Available positions are:</p> <ul> <li><code>\"first\"</code></li> <li><code>\"last\"</code></li> <li><code>\"default\"</code></li> <li><code>\"after\"</code></li> <li><code>\"before\"</code></li> </ul> <p>When using <code>\"after\"</code> or <code>\"before\"</code>, you must also specify the <code>reference</code> parameter with the name of the node you want to add the component after or before.</p> <p>You can also specify the <code>stage</code> parameter to add the component to a specific stage group of the pipeline.</p> <pre><code>@pipeline.add_node(position=\"after\", reference=\"tokenize\", stage=\"preprocessing\")\ndef remove_stopwords(doc: Document) -&gt; Document:\n    stopwords = {\"the\", \"a\", \"an\", \"in\", \"on\", \"at\"}\n    doc.tokens = [token for token in doc.tokens if token not in stopwords]\n    return doc\n</code></pre> <p>You can specify dependencies between components using the <code>dependencies</code> parameter. This is useful if you want to ensure that a component is run after another component.</p> <pre><code>@pipeline.add_node(dependencies=[\"tokenize\"])\ndef remove_stopwords(doc: Document) -&gt; Document:\n    stopwords = {\"the\", \"a\", \"an\", \"in\", \"on\", \"at\"}\n    doc.tokens = [token for token in doc.tokens if token not in stopwords]\n    return doc\n</code></pre>"},{"location":"reference/pipeline/pipeline/#removing","title":"Removing","text":"<p>Use <code>.remove()</code> to remove a component from the pipeline.</p> <pre><code>pipeline.remove(\"remove_stopwords\")\n</code></pre>"},{"location":"reference/pipeline/pipeline/#replacing","title":"Replacing","text":"<p>Use <code>.replace()</code> to replace a component in the pipeline.</p> <pre><code>def remove_names(doc: Document) -&gt; Document:\n    doc.entities = [token for token in doc.entities if token[0].isupper() and len(token) &gt; 1]\n    return doc\n\npipeline.replace(\"remove_stopwords\", remove_names)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#inspecting-the-pipeline","title":"Inspecting the Pipeline","text":"<pre><code>print(pipeline)\nprint(pipeline.stages)\n\n# [\"TextPreprocessor\", \"Model\", \"TextPostProcessor\"]\n# preprocessing:\n#   - TextPreprocessor\n# ner+l:\n#   - Model\n# postprocessing:\n#   - TextPostProcessor\n</code></pre>"},{"location":"reference/pipeline/connectors/cdaconnector/","title":"CDA Connector","text":"<p>The <code>CdaConnector</code> handles Clinical Document Architecture (CDA) documents, serving as both an input and output connector in the pipeline. It parses CDA documents, extracting free-text notes and relevant structured clinical data into a <code>Document</code> object, and can return an annotated CDA document as output.</p> <p>This connector is particularly useful for clinical documentation improvement (CDI) workflows where CDA documents need to be processed and updated with additional structured data.</p> <p>(Full Documentation on Clinical Documentation)</p>"},{"location":"reference/pipeline/connectors/cdaconnector/#usage","title":"Usage","text":"<pre><code>from healthchain.io import CdaConnector, Document\nfrom healthchain.models import CdaRequest\nfrom healthchain.pipeline import Pipeline\n\n# Create a pipeline with CdaConnector\npipeline = Pipeline()\n\ncda_connector = CdaConnector()\npipeline.add_input(cda_connector)\npipeline.add_output(cda_connector)\n\n# Example CDA request\ncda_request = CdaRequest(document=\"&lt;CDA XML content&gt;\")\n\n# Example 1: Simple pipeline execution\npipe = pipeline.build()\ncda_response = pipe(cda_request)\nprint(cda_response)\n# Output: CdaResponse(document='&lt;Annotated CDA XML content&gt;')\n\n# Example 2: Accessing CDA data inside a pipeline node\n@pipeline.add_node\ndef example_pipeline_node(document: Document) -&gt; Document:\n    print(document.ccd_data)\n    return document\n\npipe = pipeline.build()\ncda_response = pipe(cda_request)\n# Output: CcdData object...\n</code></pre>"},{"location":"reference/pipeline/connectors/cdaconnector/#accessing-data-inside-your-pipeline","title":"Accessing data inside your pipeline","text":"<p>Data parsed from the CDA document is stored in the <code>Document.ccd_data</code> attribute as a <code>CcdData</code> object, as shown in the example above.</p> <p>(CcdData Reference)</p>"},{"location":"reference/pipeline/connectors/cdaconnector/#configuration","title":"Configuration","text":"<p>The <code>overwrite</code> parameter in the <code>CdaConnector</code> constructor determines whether existing data in the document should be overwritten. This can be useful for readability with very long CDA documents when the receiving system does not require the full document.</p> <pre><code>cda_connector = CdaConnector(overwrite=True)\n</code></pre>"},{"location":"reference/pipeline/connectors/cdsfhirconnector/","title":"CDS FHIR Connector","text":"<p>The <code>CdsFhirConnector</code> handles FHIR data in the context of Clinical Decision Support (CDS) services, serving as both an input and output connector in the pipeline.</p> <p>Note that this is not meant to be used as a generic FHIR connector, but specifically designed for use with the CDS Hooks specification.</p> <p>(Full Documentation on Clinical Decision Support)</p>"},{"location":"reference/pipeline/connectors/cdsfhirconnector/#usage","title":"Usage","text":"<pre><code>from healthchain.io import CdsFhirConnector, Document\nfrom healthchain.models import CDSRequest\nfrom healthchain.pipeline import Pipeline\n\n# Create a pipeline with CdsFhirConnector\npipeline = Pipeline()\n\ncds_fhir_connector = CdsFhirConnector()\npipeline.add_input(cds_fhir_connector)\npipeline.add_output(cds_fhir_connector)\n\n# Example CDS request\ncds_request = CDSRequest(\n    hook=\"patient-view\",\n    hookInstance=\"d1577c69-dfbe-44ad-ba6d-3e05e953b2ea\",\n    context={\n        \"userId\": \"Practitioner/123\",\n        \"patientId\": \"Patient/456\"\n    },\n    prefetch={\n        \"patient\": {\n            \"resourceType\": \"Patient\",\n            \"id\": \"456\",\n            \"name\": [{\"family\": \"Doe\", \"given\": [\"John\"]}],\n            \"birthDate\": \"1970-01-01\"\n        }\n    }\n)\n\n# Example 1: Simple pipeline execution\npipe = pipeline.build()\ncds_response = pipe(cds_request)\nprint(cds_response)\n# Output: CDSResponse with cards...\n\n# Example 2: Accessing FHIR data inside a pipeline node\n@pipeline.add_node\ndef example_pipeline_node(document: Document) -&gt; Document:\n    print(document.fhir_resources)\n    return document\n\npipe = pipeline.build()\ncds_response = pipe(cds_request)\n# Output: CdsFhirData object...\n</code></pre>"},{"location":"reference/pipeline/connectors/cdsfhirconnector/#accessing-data-inside-your-pipeline","title":"Accessing data inside your pipeline","text":"<p>Data parsed from the FHIR resources is stored in the <code>Document.fhir_resources</code> attribute as a <code>CdsFhirData</code> object, as shown in the example above.</p> <p>(CdsFhirData Reference)</p>"},{"location":"reference/pipeline/connectors/connectors/","title":"Connectors","text":"<p>Connectors transform your data into a format that can be understood by healthcare systems such as EHRs. They allow your pipelines to work directly with data in HL7 interoperability standard formats, such as CDA or FHIR, without the headache of parsing and validating the data yourself.</p> <p>Connectors are what give you the power to build end-to-end pipelines that interact with real-time healthcare systems.</p>"},{"location":"reference/pipeline/connectors/connectors/#available-connectors","title":"Available connectors","text":"<p>Connectors make certain assumptions about the data they receive depending on the use case to convert it to an appropriate internal data format and container.</p> <p>Some connectors require the same instance to be used for both input and output, while others may be input or output only.</p> Connector Input Output Internal Data Representation Access it by... Same instance I/O? CdaConnector <code>CdaRequest</code> <code>Document</code> <code>Document</code> <code>CdaRequest</code> CcdData <code>.ccd_data</code> \u2705 CdsFhirConnector <code>CDSRequest</code> <code>Document</code> <code>Document</code> <code>CdsResponse</code> CdsFhirData <code>.fhir_resources</code> \u2705 <p>CdaConnector Example</p> <p>The <code>CdaConnector</code> expects a <code>CdaRequest</code> object as input and outputs a <code>CdaResponse</code> object. The connector converts the input data into a <code>Document</code> object because CDAs are usually represented as a document object.</p> <p>This <code>Document</code> object contains a <code>.ccd_data</code> attribute, which stores the structured data from the CDA document in a <code>CcdData</code> object. Any free-text notes are stored in the <code>Document.text</code> attribute.</p> <p>Because CDAs are annotated documents, the same <code>CdaConnector</code> instance must be used for both input and output operations in the pipeline.</p>"},{"location":"reference/pipeline/connectors/connectors/#use-cases","title":"Use Cases","text":"<p>Each connector can be mapped to a specific use case in the sandbox module.</p> Connector Use Case <code>CdaConnector</code> Clinical Documentation <code>CdsFhirConnector</code> Clinical Decision Support"},{"location":"reference/pipeline/connectors/connectors/#adding-connectors-to-your-pipeline","title":"Adding connectors to your pipeline","text":"<p>To add connectors to your pipeline, use the <code>.add_input()</code> and <code>.add_output()</code> methods.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io import CdaConnector\n\npipeline = Pipeline()\n# In this example, we're using the same connector instance for input and output\ncda_connector = CdaConnector()\n\npipeline.add_input(cda_connector)\npipeline.add_output(cda_connector)\n</code></pre> <p>Connectors are currently intended for development and testing purposes only. They are not production-ready, although this is something we want to work towards on our long-term roadmap. If there is a specific connector you would like to see, please feel free to open an issue or contact us!</p>"},{"location":"reference/sandbox/client/","title":"Client","text":"<p>A client is a healthcare system object that requests information and processing from an external service. This is typically an EHR system, but we may also support other health objects in the future such as a CPOE (Computerized Physician Order Entry).</p> <p>We can mark a client by using the decorator <code>@hc.ehr</code>. You must declare a particular workflow for the EHR client, which informs the sandbox how your data will be formatted. You can find more information on the Use Cases documentation page.</p> <p>Data returned from the client should be wrapped in a Pydantic model depending on use case, e.g. <code>CdsFhirData</code>.</p> <p>You can optionally specify the number of requests to generate with the <code>num</code> parameter.</p> Clinical DocumentationCDS <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDocumentation\nfrom healthchain.models import CcdData\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDocumentation):\n    def __init__(self) -&gt; None:\n        pass\n\n    @hc.ehr(workflow=\"sign-note-inpatient\", num=10)\n    def load_data_in_client(self) -&gt; CcdData:\n        # Do things here to load in your data\n        return CcdData(cda_xml=\"\")\n</code></pre> <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.models import CdsFhirData\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDecisionSupport):\n    def __init__(self) -&gt; None:\n        pass\n\n    @hc.ehr(workflow=\"patient-view\", num=10)\n    def load_data_in_client(self) -&gt; CdsFhirData:\n        # Do things here to load in your data\n        return CdsFhirData(context={}, prefetch={})\n</code></pre>"},{"location":"reference/sandbox/sandbox/","title":"Sandbox","text":"<p>Designing your pipeline to integrate well in a healthcare context is an essential step to turning it into an application that could potentially be adapted for real-world use. As a developer who has years of experience deploying healthcare NLP solutions into hospitals, I know how painful and slow this process can be.</p> <p>A sandbox makes this process easier. It provides a staging environment to debug, test, track, and interact with your application in realistic deployment scenarios without having to gain access to such environments, especially ones that are tightly integrated with local EHR configurations. Think of it as integration testing in healthcare systems.</p> <p>For a given sandbox run:</p> <ol> <li> <p>Data is generated or loaded into a client (EHR)</p> </li> <li> <p>Data is wrapped and sent as standardized API requests the designated service</p> </li> <li> <p>Data is processed by the service (you application)</p> </li> <li> <p>Processed result is wrapped and sent back to the service as a standardized API response</p> </li> <li> <p>Data is received by the client which could be rendered in a UI interface</p> </li> </ol> <p>To create a sandbox, initialize a class that inherits from a type of <code>UseCase</code> and decorate it with the <code>@hc.sandbox</code> decorator. <code>UseCase</code> loads in the blueprint of the API endpoints for the specified use case, and <code>@hc.sandbox</code> orchestrates these interactions.</p> <p>Every sandbox also requires a Client function marked by <code>@hc.ehr</code> and a Service function marked by <code>@hc.api</code>. Every client function must specify a workflow that informs the sandbox how your data will be formatted. For more information on workflows, see the Use Cases documentation.</p> <p>For each sandbox you need to specify...</p> <ul> <li>Use case</li> <li>service function</li> <li>client function</li> <li>workflow of client</li> </ul> <pre><code>import healthchain as hc\n\nfrom healthchain.pipeline import SummarizationPipeline\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.data_generators import CdsDataGenerator\nfrom healthchain.models import CDSRequest, CdsFhirData, CDSResponse\n\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDecisionSupport):\n    def __init__(self):\n        self.data_generator = CdsDataGenerator()\n        self.pipeline = SummarizationPipeline('gpt-4o')\n\n    @hc.ehr(workflow=\"encounter-discharge\")\n    def load_data_in_client(self) -&gt; CdsFhirData:\n        cds_fhir_data = self.data_generator.generate()\n        return cds_fhir_data\n\n    @hc.api\n    def my_service(self, request: CDSRequest) -&gt; CDSResponse:\n        cds_response = self.pipeline(request)\n        return cds_response\n\nif __name__ == \"__main__\":\n    cds = MyCoolSandbox()\n    cds.start_sandbox()\n</code></pre>"},{"location":"reference/sandbox/service/","title":"Service","text":"<p>A service is typically an API of a third-party system that returns data to the client, the healthcare provider object. This is where you define your application logic.</p> <p>When you decorate a function with <code>@hc.api</code> in a sandbox, the function is mounted standardized API endpoint an EHR client can make requests to. This can be defined by healthcare interoperability standards, such as HL7, or the EHR provider. HealthChain will start a FastAPI server with these APIs pre-defined for you.</p> <p>Your service function receives use case specific request data as input and returns the response data.</p> <p>We recommend you initialize your pipeline in the class <code>__init__</code> method.</p> <p>Here are minimal examples for each use case:</p> Clinical DocumentationCDS <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDocumentation\nfrom healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CcdData, CdaRequest, CdaResponse\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDocumentation):\n    def __init__(self):\n        self.pipeline = MedicalCodingPipeline.load(\"./path/to/model\")\n\n    @hc.ehr(workflow=\"sign-note-inpatient\")\n    def load_data_in_client(self) -&gt; CcdData:\n        with open('/path/to/data.xml', \"r\") as file:\n            xml_string = file.read()\n\n        return CcdData(cda_xml=xml_string)\n\n    @hc.api\n    def my_service(self, request: CdaRequest) -&gt; CdaResponse:\n        response = self.pipeline(request)\n        return response\n</code></pre> <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.pipeline import SummarizationPipeline\nfrom healthchain.models import CDSRequest, CDSResponse, CdsFhirData\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDecisionSupport):\n    def __init__(self):\n        self.pipeline = SummarizationPipeline.load(\"mode-name\")\n\n    @hc.ehr(workflow=\"patient-view\")\n    def load_data_in_client(self) -&gt; CdsFhirData:\n        with open('/path/to/data.json', \"r\") as file:\n            fhir_json = file.read()\n\n        return CdsFhirData(**fhir_json)\n\n    @hc.api\n    def my_service(self, request: CDSRequest) -&gt; CDSResponse:\n        response = self.pipeline(request)\n        return response\n</code></pre>"},{"location":"reference/sandbox/use_cases/cds/","title":"Use Cases","text":""},{"location":"reference/sandbox/use_cases/cds/#clinical-decision-support-cds","title":"Clinical Decision Support (CDS)","text":"<p>CDS workflows are based on CDS Hooks. CDS Hooks is an HL7 published specification for clinical decision support. CDS hooks communicate using FHIR (Fast Healthcare Interoperability Resources). For more information you can consult the official documentation.</p> When Where What you receive What you send back Triggered at certain events during a clinician's workflow, e.g. when a patient record is opened. EHR The context of the event and FHIR resources that are requested by your service. e.g. patient ID, <code>Encounter</code> and <code>Patient</code>. \u201cCards\u201d displaying text, actionable suggestions, or links to launch a SMART app from within the workflow."},{"location":"reference/sandbox/use_cases/cds/#data-flow","title":"Data Flow","text":"Stage Input Internal Data Representation Output Client N/A N/A <code>CdsFhirData</code> Service <code>CdsRequest</code> <code>CdsFhirData</code> <code>CdsResponse</code> <p>CdsFhirConnector handles the conversion of <code>CDSRequests</code> <code>CdsFhirData</code> <code>CdsResponse</code> in a HealthChain pipeline.</p> <p>Attributes of <code>CdsFhirData</code> are:</p> <ul> <li><code>context</code></li> <li><code>prefetch</code></li> </ul> <p>(CdsFhirData API Reference)</p>"},{"location":"reference/sandbox/use_cases/cds/#supported-workflows","title":"Supported Workflows","text":"Workflow Name Description Trigger Maturity <code>patient-view</code> Triggered when a patient chart is opened Opening a patient's chart \u2705 <code>order-select</code> Triggered when a new order is selected Selecting a new order \u23f3 <code>order-sign</code> Triggered when orders are being signed Signing orders \u23f3 <code>encounter-discharge</code> Triggered when a patient is being discharged Discharging a patient \u2705"},{"location":"reference/sandbox/use_cases/cds/#generated-api-endpoints","title":"Generated API Endpoints","text":"Endpoint Method Function Name API Protocol <code>/cds-services</code> GET <code>cds_discovery</code> REST <code>/cds-services/{id}</code> POST <code>cds_service</code> REST"},{"location":"reference/sandbox/use_cases/cds/#what-does-the-data-look-like","title":"What does the data look like?","text":""},{"location":"reference/sandbox/use_cases/cds/#example-cdsrequest","title":"Example <code>CDSRequest</code>","text":"<pre><code>{\n   \"hookInstance\" : \"23f1a303-991f-4118-86c5-11d99a39222e\",\n   \"fhirServer\" : \"https://fhir.example.org\",\n   \"hook\" : \"patient-view\",\n   \"context\" : {\n     \"patientId\" : \"1288992\",\n     \"userId\" : \"Practitioner/example\"\n    },\n   \"prefetch\" : {\n      \"patientToGreet\" : {\n        \"resourceType\" : \"Patient\",\n        \"gender\" : \"male\",\n        \"birthDate\" : \"1925-12-23\",\n        \"id\" : \"1288992\",\n        \"active\" : true\n      }\n   }\n}\n</code></pre>"},{"location":"reference/sandbox/use_cases/cds/#example-cdsresponse","title":"Example <code>CDSResponse</code>","text":"<pre><code>{\n  \"summary\": \"Bilirubin: Based on the age of this patient consider overlaying bilirubin [Mass/volume] results over a time-based risk chart\",\n  \"indicator\": \"info\",\n  \"detail\": \"The focus of this app is to reduce the incidence of severe hyperbilirubinemia and bilirubin encephalopathy while minimizing the risks of unintended harm such as maternal anxiety, decreased breastfeeding, and unnecessary costs or treatment.\",\n  \"source\": {\n    \"label\": \"Intermountain\",\n    \"url\": null\n  },\n  \"links\": [\n    {\n      \"label\": \"Bilirubin SMART app\",\n      \"url\": \"https://example.com/launch\",\n      \"type\": \"smart\"\n   }\n  ]\n}\n</code></pre>"},{"location":"reference/sandbox/use_cases/cds/#implemented-fhir-resources","title":"Implemented FHIR Resources","text":"<ul> <li><code>Patient</code></li> <li><code>Encounter</code></li> <li><code>Procedure</code></li> <li><code>MedicationRequest</code></li> </ul>"},{"location":"reference/sandbox/use_cases/clindoc/","title":"Clinical Documentation","text":"<p>The <code>ClinicalDocumentation</code> use case implements a real-time Clinical Documentation Improvement (CDI) service. It currently implements the Epic-integrated NoteReader CDI specification, which communicates with a third-party NLP engine to analyse clinical notes and extract structured data. It helps convert free-text medical documentation into coded information that can be used for billing, quality reporting, and clinical decision support.</p> <p><code>ClinicalDocumentation</code> communicates using CDA (Clinical Document Architecture). CDAs are standardized electronic documents for exchanging clinical information. They provide a common structure for capturing and sharing patient data like medical history, medications, and care plans between different healthcare systems and providers. Think of it as a collaborative Google Doc that you can add, amend, and remove entries from.</p> When Where What you receive What you send back Triggered when a clinician opts in to a CDI functionality and signs or pends a note after writing it. Specific modules in EHR where clinical documentation takes place, such as NoteReader in Epic. A CDA document which contains continuity of care data and free-text data, e.g. a patient's problem list and the progress note that the clinician has entered in the EHR. A CDA document which contains additional structured data extracted and returned by your CDI service."},{"location":"reference/sandbox/use_cases/clindoc/#data-flow","title":"Data Flow","text":"Stage Input Internal Data Representation Output Client N/A N/A <code>CcdData</code> Service <code>CdaRequest</code> <code>CcdData</code> <code>CdaResponse</code> <p>CdaConnector handles the conversion of <code>CdaRequests</code> <code>CcdData</code> <code>CdaResponse</code> in a HealthChain pipeline.</p> <p>Attributes of <code>CcdData</code> are:</p> <ul> <li><code>problems</code></li> <li><code>allergies</code></li> <li><code>medications</code></li> <li><code>note</code></li> </ul> <p>(CcdData API Reference)</p>"},{"location":"reference/sandbox/use_cases/clindoc/#supported-workflows","title":"Supported Workflows","text":"Workflow Name Description Trigger Maturity <code>sign-note-inpatient</code> Triggered when a clinician opts in to a CDI functionality and signs or pends a note after writing it in an inpatient setting. Signing or pending a note in Epic \u2705 <code>sign-note-outpatient</code> Triggered when a clinician opts in to a CDI functionality and signs or pends a note after writing it in an outpatient setting. Signing or pending a note in Epic \u23f3 <p>We support parsing of problems, medications, and allergies sections, though some of the data fields may be limited. We plan to implement additional CDI services and workflows for different vendor specifications.</p>"},{"location":"reference/sandbox/use_cases/clindoc/#generated-api-endpoints","title":"Generated API Endpoints","text":"Endpoint Method Function API Protocol <code>/notereader/</code> POST <code>process_notereader_document</code> SOAP <p>Note that NoteReader is a vendor-specific component (Epic). This particular note-based workflow is one type of CDI service. Different EHR vendors will have different support for third-party CDI services.</p>"},{"location":"reference/sandbox/use_cases/clindoc/#what-does-the-data-look-like","title":"What does the data look like?","text":""},{"location":"reference/sandbox/use_cases/clindoc/#example-cda-request","title":"Example CDA Request","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n  &lt;typeId root=\"2.16.840.1.113883.1.3\" extension=\"POCD_HD000040\"/&gt;\n  &lt;templateId root=\"2.16.840.1.113883.10.20.22.1.2\"/&gt;\n  &lt;id root=\"2.16.840.1.113883.19.5.99999.1\"/&gt;\n  &lt;code code=\"34133-9\" displayName=\"Summarization of Episode Note\" codeSystem=\"2.16.840.1.113883.6.1\" codeSystemName=\"LOINC\"/&gt;\n  &lt;title&gt;CDA Document with Problem List and Progress Note&lt;/title&gt;\n  &lt;effectiveTime value=\"20240712\"/&gt;\n  &lt;confidentialityCode code=\"N\" codeSystem=\"2.16.840.1.113883.5.25\"/&gt;\n  &lt;languageCode code=\"en-US\"/&gt;\n\n  &lt;component&gt;\n    &lt;structuredBody&gt;\n      &lt;!-- Problem List Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.5.1\"/&gt;\n          &lt;code code=\"11450-4\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"Problem List\"/&gt;\n          &lt;title&gt;Problems&lt;/title&gt;\n          &lt;text&gt;\n            &lt;list&gt;\n              &lt;item&gt;Hypertension&lt;/item&gt;\n            &lt;/list&gt;\n          &lt;/text&gt;\n          &lt;entry&gt;\n            &lt;act classCode=\"ACT\" moodCode=\"EVN\"&gt;\n              &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.3\"/&gt;\n              &lt;id root=\"ab1791b0-5c71-11db-b0de-0800200c9a66\"/&gt;\n              &lt;code code=\"CONC\" codeSystem=\"2.16.840.1.113883.5.6\"/&gt;\n              &lt;statusCode code=\"active\"/&gt;\n              &lt;effectiveTime&gt;\n                &lt;low value=\"20240712\"/&gt;\n              &lt;/effectiveTime&gt;\n              &lt;entryRelationship typeCode=\"SUBJ\"&gt;\n                &lt;observation classCode=\"OBS\" moodCode=\"EVN\"&gt;\n                  &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.4\"/&gt;\n                  &lt;id root=\"ab1791b0-5c71-11db-b0de-0800200c9a66\"/&gt;\n                  &lt;code code=\"55607006\" displayName=\"Problem\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\"/&gt;\n                  &lt;text&gt;Hypertension&lt;/text&gt;\n                  &lt;statusCode code=\"completed\"/&gt;\n                  &lt;effectiveTime&gt;\n                    &lt;low value=\"20240712\"/&gt;\n                  &lt;/effectiveTime&gt;\n                  &lt;value xsi:type=\"CD\" code=\"59621000\" displayName=\"Essential hypertension\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\"/&gt;\n                &lt;/observation&gt;\n              &lt;/entryRelationship&gt;\n            &lt;/act&gt;\n          &lt;/entry&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n\n      &lt;!-- Progress Note Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.65\"/&gt;\n          &lt;code code=\"11506-3\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"Progress Note\"/&gt;\n          &lt;title&gt;Progress Note&lt;/title&gt;\n          &lt;text&gt;\n            &lt;paragraph&gt;Patient's blood pressure remains elevated. Discussed lifestyle modifications and medication adherence. Started Lisinopril 10 mg daily for hypertension management. Will follow up in 3 months to assess response to treatment.&lt;/paragraph&gt;\n          &lt;/text&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n    &lt;/structuredBody&gt;\n  &lt;/component&gt;\n&lt;/ClinicalDocument&gt;\n</code></pre>"},{"location":"reference/sandbox/use_cases/clindoc/#example-cda-response","title":"Example CDA Response","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n  &lt;typeId root=\"2.16.840.1.113883.1.3\" extension=\"POCD_HD000040\"/&gt;\n  &lt;templateId root=\"2.16.840.1.113883.10.20.22.1.2\"/&gt;\n  &lt;id root=\"2.16.840.1.113883.19.5.99999.1\"/&gt;\n  &lt;code code=\"34133-9\" displayName=\"Summarization of Episode Note\" codeSystem=\"2.16.840.1.113883.6.1\" codeSystemName=\"LOINC\"/&gt;\n  &lt;title&gt;CDA Document with Problem List, Medication, and Progress Note&lt;/title&gt;\n  &lt;effectiveTime value=\"20240712\"/&gt;\n  &lt;confidentialityCode code=\"N\" codeSystem=\"2.16.840.1.113883.5.25\"/&gt;\n  &lt;languageCode code=\"en-US\"/&gt;\n\n  &lt;component&gt;\n    &lt;structuredBody&gt;\n      &lt;!-- Problem List Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.5.1\"/&gt;\n          &lt;code code=\"11450-4\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"Problem List\"/&gt;\n          &lt;title&gt;Problems&lt;/title&gt;\n          &lt;text&gt;\n            &lt;list&gt;\n              &lt;item&gt;Hypertension&lt;/item&gt;\n            &lt;/list&gt;\n          &lt;/text&gt;\n          &lt;entry&gt;\n            &lt;act classCode=\"ACT\" moodCode=\"EVN\"&gt;\n              &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.3\"/&gt;\n              &lt;id root=\"ab1791b0-5c71-11db-b0de-0800200c9a66\"/&gt;\n              &lt;code code=\"CONC\" codeSystem=\"2.16.840.1.113883.5.6\"/&gt;\n              &lt;statusCode code=\"active\"/&gt;\n              &lt;effectiveTime&gt;\n                &lt;low value=\"20240712\"/&gt;\n              &lt;/effectiveTime&gt;\n              &lt;entryRelationship typeCode=\"SUBJ\"&gt;\n                &lt;observation classCode=\"OBS\" moodCode=\"EVN\"&gt;\n                  &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.4\"/&gt;\n                  &lt;id root=\"ab1791b0-5c71-11db-b0de-0800200c9a66\"/&gt;\n                  &lt;code code=\"55607006\" displayName=\"Problem\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\"/&gt;\n                  &lt;text&gt;Hypertension&lt;/text&gt;\n                  &lt;statusCode code=\"completed\"/&gt;\n                  &lt;effectiveTime&gt;\n                    &lt;low value=\"20240712\"/&gt;\n                  &lt;/effectiveTime&gt;\n                  &lt;value xsi:type=\"CD\" code=\"59621000\" displayName=\"Essential hypertension\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\"/&gt;\n                &lt;/observation&gt;\n              &lt;/entryRelationship&gt;\n            &lt;/act&gt;\n          &lt;/entry&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n\n      &lt;!-- Medications Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.1.1\"/&gt;\n          &lt;code code=\"10160-0\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"History of medication use\"/&gt;\n          &lt;title&gt;Medications&lt;/title&gt;\n          &lt;text&gt;\n            &lt;list&gt;\n              &lt;item&gt;Lisinopril 10 mg oral tablet, once daily&lt;/item&gt;\n            &lt;/list&gt;\n          &lt;/text&gt;\n          &lt;entry&gt;\n            &lt;substanceAdministration classCode=\"SBADM\" moodCode=\"EVN\"&gt;\n              &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.16\"/&gt;\n              &lt;id root=\"cdbd33f0-6cde-11db-9fe1-0800200c9a66\"/&gt;\n              &lt;statusCode code=\"active\"/&gt;\n              &lt;effectiveTime xsi:type=\"IVL_TS\"&gt;\n                &lt;low value=\"20240712\"/&gt;\n              &lt;/effectiveTime&gt;\n              &lt;routeCode code=\"PO\" codeSystem=\"2.16.840.1.113883.5.112\" displayName=\"Oral\"/&gt;\n              &lt;doseQuantity value=\"1\"/&gt;\n              &lt;administrationUnitCode code=\"C48542\" displayName=\"Tablet\" codeSystem=\"2.16.840.1.113883.3.26.1.1\"/&gt;\n              &lt;consumable&gt;\n                &lt;manufacturedProduct classCode=\"MANU\"&gt;\n                  &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.23\"/&gt;\n                  &lt;manufacturedMaterial&gt;\n                    &lt;code code=\"197884\" codeSystem=\"2.16.840.1.113883.6.88\" displayName=\"Lisinopril 10 MG Oral Tablet\"&gt;\n                      &lt;originalText&gt;Lisinopril 10 mg oral tablet&lt;/originalText&gt;\n                    &lt;/code&gt;\n                  &lt;/manufacturedMaterial&gt;\n                &lt;/manufacturedProduct&gt;\n              &lt;/consumable&gt;\n              &lt;entryRelationship typeCode=\"SUBJ\"&gt;\n                &lt;observation classCode=\"OBS\" moodCode=\"EVN\"&gt;\n                  &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.20\"/&gt;\n                  &lt;code code=\"33999-4\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"Indication\"/&gt;\n                  &lt;value xsi:type=\"CD\" code=\"59621000\" displayName=\"Essential hypertension\" codeSystem=\"2.16.840.1.113883.6.96\"/&gt;\n                &lt;/observation&gt;\n              &lt;/entryRelationship&gt;\n            &lt;/substanceAdministration&gt;\n          &lt;/entry&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n\n      &lt;!-- Progress Note Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.65\"/&gt;\n          &lt;code code=\"11506-3\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"Progress Note\"/&gt;\n          &lt;title&gt;Progress Note&lt;/title&gt;\n          &lt;text&gt;\n            &lt;paragraph&gt;Patient's blood pressure remains elevated. Discussed lifestyle modifications and medication adherence. Started Lisinopril 10 mg daily for hypertension management. Will follow up in 3 months to assess response to treatment.&lt;/paragraph&gt;\n          &lt;/text&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n    &lt;/structuredBody&gt;\n  &lt;/component&gt;\n&lt;/ClinicalDocument&gt;\n</code></pre>"},{"location":"reference/sandbox/use_cases/clindoc/#implemented-cda-sections","title":"Implemented CDA Sections","text":"<ul> <li>Problems</li> <li>Medications (including information on dosage, frequency, duration, route)</li> <li>Allergies (including information on severity, reaction and type of allergen)</li> <li>Progress Note (free-text)</li> </ul>"},{"location":"reference/sandbox/use_cases/use_cases/","title":"Use Cases","text":"<p>Use cases are the core building blocks of sandboxes. They define the API endpoints and the data formats for a given workflow.</p> <p>We currently support:</p> <ul> <li>Clinical Decision Support</li> <li>Clinical Documentation</li> </ul> <p>More documentation on the pros and cons of each use case will be added soon. For now, you can refer to the source code for more details.</p>"},{"location":"reference/utilities/cda_parser/","title":"CDA Parser","text":"<p>The <code>CdaAnnotator</code> class is responsible for parsing and annotating CDA (Clinical Document Architecture) documents. It extracts information about problems, medications, allergies, and notes from the CDA document, and allows you to add new information to the CDA document.</p> <p>The CDA parser is used in the CDA Connector module, but can also be used independently.</p> <p>Internally, <code>CdaAnnotator</code> parses CDA documents from XML strings to a dictionary-based representation using <code>xmltodict</code> and uses Pydantic for data validation. New problems are added to the CDA document using a template-based approach. It's currently not super configurable, but we're working on it.</p> <p>Data interacts with the <code>CdaAnnotator</code> through <code>Concept</code> data models, which are designed to be an system-agnostic intermediary between FHIR and CDA data representations.</p> <p>(CdaAnnotator API Reference | Concept API Reference)</p>"},{"location":"reference/utilities/cda_parser/#usage","title":"Usage","text":""},{"location":"reference/utilities/cda_parser/#parsing-cda-documents","title":"Parsing CDA documents","text":"<p>Parse a CDA document from an XML string:</p> <pre><code>from healthchain.cda_parser import CdaAnnotator\n\ncda = CdaAnnotator.from_xml(cda_xml_string)\n\nproblems = cda.problem_list\nmedications = cda.medication_list\nallergies = cda.allergy_list\nnote = cda.note\n\nprint([problem.name for problem in problems])\nprint([medication.name for medication in medications])\nprint([allergy.name for allergy in allergies])\nprint(note)\n</code></pre> <p>You can access data parsed from the CDA document in the <code>problem_list</code>, <code>medication_list</code>, <code>allergy_list</code>, and <code>note</code> attributes of the <code>CdaAnnotator</code> instance. They return a list of <code>Concept</code> data models.</p>"},{"location":"reference/utilities/cda_parser/#adding-new-information-to-the-cda-document","title":"Adding new information to the CDA document","text":"<p>The methods currently available for adding new information to the CDA document are:</p> Method Description <code>.add_to_problem_list()</code> Adds a list of ProblemConcept <code>.add_to_medication_list()</code> Adds a list of MedicationConcept <code>.add_to_allergy_list()</code> Adds a list of AllergyConcept <p>The <code>overwrite</code> parameter in the <code>add_to_*_list()</code> methods is used to determine whether to overwrite the existing list or append to it. If <code>overwrite</code> is <code>True</code>, the existing list will be replaced with the new list. If <code>overwrite</code> is <code>False</code>, the new list will be appended to the existing list.</p> <p>Depending on the use case, you don't always need to return the original list of information in the CDA document you receive, although this is mostly useful if you are just developing and don't want the eye-strain of a lengthy CDA document.</p>"},{"location":"reference/utilities/cda_parser/#exporting-the-cda-document","title":"Exporting the CDA document","text":"<pre><code>xml_string = cda.export(pretty_print=True)\n</code></pre> <p>The <code>pretty_print</code> parameter is optional and defaults to <code>True</code>. If <code>pretty_print</code> is <code>True</code>, the XML string will be formatted with newlines and indentation.</p>"},{"location":"reference/utilities/cda_parser/#example","title":"Example","text":"<pre><code>from healthchain.cda_parser import CdaAnnotator\nfrom healthchain.models import ProblemConcept, MedicationConcept, AllergyConcept\n\ncda = CdaAnnotator.from_xml(cda_xml_string)\n\nnew_problems = [ProblemConcept(name=\"New Problem\", code=\"123456\")]\nnew_medications = [MedicationConcept(name=\"New Medication\", code=\"789012\")]\nnew_allergies = [AllergyConcept(name=\"New Allergy\", code=\"345678\")]\n\n# Add new problems, medications, and allergies\ncda.add_to_problem_list(new_problems, overwrite=True)\ncda.add_to_medication_list(new_medications, overwrite=True)\ncda.add_to_allergy_list(new_allergies, overwrite=True)\n\n# Export the modified CDA document\nmodified_cda_xml = cda.export()\n</code></pre> <p>The CDA parser is a work in progress. I'm just gonna be real with you, CDAs are the bane of my existence. If you, for some reason, love working with XML-based documents, please get in touch! We have plans to implement more functionality in the future, including allowing configurable templates, more CDA section methods, and using LLMs as a fallback parsing method.</p>"},{"location":"reference/utilities/data_generator/","title":"Data Generator","text":"<p>Healthcare data is interoperable, but not composable - every deployment site will have different ways of configuring data and terminology. This matters when you develop applications that need to integrate into these systems, especially when you need to reliably extract data for your model to consume.</p> <p>The aim of the data generator is not to generate realistic data suitable for use cases such as patient population studies, but rather to generate data that is structurally compliant with what is expected of EHR configurations, and to be able to test and handle variations in this.</p> <p>For this reason the data generator is opinionated by specific workflows and use cases.</p> <p>Note</p> <p>We're aware we may not cover everyone's use cases, so if you have strong opinions about this, please reach out!</p> <p>On the synthetic data spectrum defined by this UK ONS methodology working paper, HealthChain generates level 1: synthetic structural data.</p> <p></p>"},{"location":"reference/utilities/data_generator/#cds-data-generator","title":"CDS Data Generator","text":"<p>The <code>.generate()</code> method will return a <code>CdsFhirData</code> model with the <code>prefetch</code> field populated with a Bundle of generated structural synthetic FHIR data.</p> <p>For each workflow, a pre-configured list of FHIR resources is randomly generated and placed in the <code>prefetch</code> field of a <code>CDSRequest</code>.</p> <p>Current implemented workflows:</p> Workflow Implementation Completeness Generated Synthetic Resources patient-view <code>Patient</code>, <code>Encounter</code> (Future: <code>MedicationStatement</code>, <code>AllergyIntolerance</code>) encounter-discharge <code>Patient</code>, <code>Encounter</code>, <code>Procedure</code>, <code>MedicationRequest</code>, Optional <code>DocumentReference</code> order-sign  Partial Future: <code>MedicationRequest</code>, <code>ProcedureRequest</code>, <code>ServiceRequest</code> order-select  Partial Future: <code>MedicationRequest</code>, <code>ProcedureRequest</code>, <code>ServiceRequest</code> <p>For more information on CDS workflows, see the CDS Use Case documentation.</p> <p>You can use the data generator within a client function or on its own.</p> Within clientOn its own <pre><code>import healthchain as hc\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.models import CdsFhirData\nfrom healthchain.data_generators import CdsDataGenerator\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDecisionSupport):\n    def __init__(self) -&gt; None:\n        self.data_generator = CdsDataGenerator()\n\n    @hc.ehr(workflow=\"patient-view\")\n    def load_data_in_client(self) -&gt; CdsFhirData:\n        data = self.data_generator.generate()\n        return data\n\n    @hc.api\n    def my_server(self, request) -&gt; None:\n        pass\n</code></pre> <pre><code>from healthchain.data_generators import CdsDataGenerator\nfrom healthchain.workflow import Workflow\n\n# Initialise data generator\ndata_generator = CdsDataGenerator()\n\n# Generate FHIR resources for use case workflow\ndata_generator.set_workflow(Workflow.encounter_discharge)\ndata = data_generator.generate()\n\nprint(data.model_dump())\n\n# {\n#    \"prefetch\": {\n#        \"entry\": [\n#            {\n#                \"resource\": ...\n#            }\n#        ]\n#    }\n#}\n</code></pre>"},{"location":"reference/utilities/data_generator/#other-synthetic-data-sources","title":"Other synthetic data sources","text":"<p>If you are looking for realistic datasets, you are also free to load your own data in a sandbox run! Check out MIMIC for comprehensive continuity of care records and free-text data, or Synthea for synthetically generated FHIR resources. Both are open-source, although you will need to complete PhysioNet Credentialing to access MIMIC.</p>"},{"location":"reference/utilities/data_generator/#loading-free-text","title":"Loading free-text","text":"<p>You can specify the <code>free_text_csv</code> field of the <code>.generate()</code> method to load in free-text sources into the data generator, e.g. discharge summaries. This will wrap the text into a FHIR DocumentReference resource (N.B. currently we place the text directly in the resource attachment, although it is technically supposed to be base64 encoded).</p> <p>A random text document from the <code>csv</code> file will be picked for each generation.</p> <pre><code># Load free text into a DocumentResource FHIR resource\ndata = data_generator.generate(free_text_csv=\"./dir/to/csv/file\")\n</code></pre>"}]}